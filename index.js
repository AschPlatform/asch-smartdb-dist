module.exports=function(e){var t={};function i(s){if(t[s])return t[s].exports;var n=t[s]={i:s,l:!1,exports:{}};return e[s].call(n.exports,n,n.exports,i),n.l=!0,n.exports}return i.m=e,i.c=t,i.d=function(e,t,s){i.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:s})},i.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i.w={},i(i.s=24)}([function(e,t){e.exports=require("util")},function(e,t,i){"use strict";var s;Object.defineProperty(t,"__esModule",{value:!0}),function(e){e[e.All=127]="All",e[e.Trace=64]="Trace",e[e.Debug=32]="Debug",e[e.Log=16]="Log",e[e.Info=8]="Info",e[e.Warn=4]="Warn",e[e.Error=2]="Error",e[e.Fatal=1]="Fatal",e[e.None=0]="None"}(s=t.LogLevel||(t.LogLevel={}));class n{get infoEnabled(){return(this.level&s.Info)>0}get traceEnabled(){return(this.level&s.Trace)>0}get debugEnabled(){return(this.level&s.Debug)>0}get logEnabled(){return(this.level&s.Log)>0}get warnEnabled(){return(this.level&s.Warn)>0}get errorEnaled(){return(this.level&s.Error)>0}get fatalEnabled(){return(this.level&s.Fatal)>0}get logLevel(){return this.level}set logLevel(e){this.level=e}constructor(e,t,i,s){this.name=e,this.level=s,this.format=i,this.logger=t}fromatMessage(e,t){const i=new Date;return`${`${i.getFullYear()}-${i.getMonth()}-${i.getDay()} ${i.getHours()}:${i.getMinutes()}:${i.getSeconds()} ${i.getMilliseconds()}`} [${t}] [${this.name}] ${e}`}info(e,...t){e=this.format?this.fromatMessage(e,"INFO"):`[${this.name}] ${e}`,this.logger.info(e,...t)}debug(e,...t){e=this.format?this.fromatMessage(e,"DEBUG"):`[${this.name}] ${e}`,this.logger.debug(e,...t)}log(e,...t){e=this.format?this.fromatMessage(e,"LOG"):`[${this.name}] ${e}`,this.logger.debug(e,...t)}trace(e,...t){e=this.format?this.fromatMessage(e,"TRACE"):`[${this.name}] ${e}`,this.logger.debug(e,...t)}warn(e,...t){e=this.format?this.fromatMessage(e,"WARN"):`[${this.name}] ${e}`,this.logger.warn(e,...t)}error(e,t){e=this.format?this.fromatMessage(e,"ERROR"):`[${this.name}] ${e}`,this.logger.error(e,t)}fatal(e,t){e=this.format?this.fromatMessage(e,"FATAL"):`[${this.name}] ${e}`,this.logger.error(e,t)}}class r{constructor(){this.defaultLogLevel=s.All,this.factory={create:e=>console,format:!0,get level(){return r.Instance.defaultLogLevel}}}static get defaultLogger(){return r.Instance.consoleLogger=r.Instance.consoleLogger||new n("default",console,!0,r.Instance.defaultLogLevel),r.Instance.consoleLogger}static get Instance(){return r.logManagerInstance=r.logManagerInstance||new r,r.logManagerInstance}static set defaultLevel(e){r.Instance.defaultLogLevel=e}static get logFactory(){return r.Instance.factory}static set logFactory(e){r.Instance.factory=e}static getLogger(e){const t=r.Instance;if(!t.factory)return r.defaultLogger;const i=t.factory.create(e),s=t.factory.level,a=t.factory.format;return new n(e||"",i,a,s)}}t.LogManager=r},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(0);t.makeJsonObject=function(e,t,i){r.argument("iterable",()=>r.notNull(e)),r.argument("getKey",()=>r.notNull(t)),r.argument("getValue",()=>r.notNull(i));let s={};for(let n of e)s[t(n)]=i(n);return s},t.deepCopy=function(e){return e?JSON.parse(JSON.stringify(e)):e},t.partial=function(e,t){r.argument("src",()=>r.notNull(e)),r.argument("keysOrKeyFilter",()=>r.notNull(t));let i=s.isFunction(t)?Object.keys(e).filter(t):t,n={};for(let t of i)n[t]=e[t];return n},t.isPrimitiveKey=function(e){return!!e&&(s.isString(e)||s.isNumber(e))};class n extends Error{constructor(e){super("Code contract Error,"+e)}}t.CodeContractError=n;class r{static verify(e,t){if(void 0===e||null===e)throw new Error("Invalid verify condition");const i=s.isFunction(e)?e():e,r=s.isFunction(t)?t():t;if(!i)throw new n(r)}static argument(e,t,i){if(!e||!t)throw new Error("argName or verify cannot be null or undefined");if(i)r.verify(t,i);else{const i=t();r.verify(i.result,`argument '${e}' ${i.message}`)}}static notNull(e){const t=null!==e&&void 0!==e;return{result:t,message:t?void 0:"cannot be null or undefined"}}static notNullOrEmpty(e){const t=r.notNull(e)&&""!==e;return{result:t,message:t?void 0:"cannot be null or undefined or empty"}}static notNullOrWhitespace(e){const t=r.notNullOrEmpty(e)&&""!==e.trim();return{result:t,message:t?void 0:"cannot be null or undefined or whitespace"}}}t.CodeContract=r},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(0),n=i(2);var r;!function(e){e.String="String",e.Number="Number",e.BigInt="BigInt",e.Text="Text",e.JSON="Json"}(r=t.FieldTypes||(t.FieldTypes={}));class a{constructor(e){n.CodeContract.argument("keyObject",()=>n.CodeContract.notNull(e)),this.keyObject=e}static make(e,t){return n.CodeContract.argument("schema",()=>n.CodeContract.notNull(e)),n.CodeContract.argument("schema",e.isCompsiteKey,"model must indentify by composite key"),n.CodeContract.argument("entity",()=>n.CodeContract.notNull(t)),new a(n.partial(t,e.compositeKeys))}static fromString(e){return n.CodeContract.argument("keyJsonString",()=>n.CodeContract.notNullOrWhitespace(e)),new a(JSON.parse(e).keyObject)}get keyJson(){return this.keyObject}get key(){return JSON.stringify(this.keyObject)}toString(){return this.key}}t.CompositeKey=a,t.isCompositeKey=function(e){return!!e&&e.keyJson};t.ModelSchema=class{constructor(e,t){this.schema=Object.assign({},e),this.name=t,this.memory=!0===e.memory,this.readonly=!0===e.readonly,this.local=!0===e.local,this.attachVersionField(this.schema),this.parseFields(),this.prototypeObject={},this.setDefaultValues(this.prototypeObject)}attachVersionField(e){e.tableFields.find(e=>"_version_"===e.name)||e.tableFields.push({name:"_version_",type:r.Number,default:0})}convertType(e){return e}parseFields(){const e=this.schema.tableFields.filter(e=>!0===e.primary_key).map(e=>e.name);if(this.cKeys=this.schema.tableFields.filter(e=>!0===e.composite_key).map(e=>e.name),this.pKey=1===e.length?e[0]:void 0,void 0!==this.pKey==this.cKeys.length>1)throw new Error("model must have primary key or composite keys, but can not both");this.allFieldTypes=new Map,this.schema.tableFields.forEach(e=>this.allFieldTypes.set(e.name,this.convertType(e.type))),this.allFields=this.schema.tableFields.map(e=>e.name),this.allIndexes=this.schema.tableFields.filter(e=>!0===e.index).map(e=>e.name),this.allJsonFields=this.schema.tableFields.filter(e=>e.type===r.JSON).map(e=>e.name)}getFieldTypes(e){return this.allFieldTypes}get schemaObject(){return this.schema}get jsonFields(){return this.allJsonFields}get isCompsiteKey(){return this.compositeKeys.length>1}get primaryKey(){return this.pKey}get compositeKeys(){return this.cKeys}get fieldNames(){return this.allFields}get indexes(){return this.allIndexes}get modelName(){return this.name}get isLocal(){return this.local}get isReadonly(){return this.readonly}get memCached(){return this.memory}setKey(e,t){if(this.isCompsiteKey){const i=t;this.cKeys.forEach(t=>e[t]=i.keyJson[t])}else e[this.primaryKey]=t;return e}getKey(e){return this.isCompsiteKey?a.make(this,e):e[this.primaryKey]}newEntity(e,t){let i=s.isString(e)?{}:new e;return this.setDefaultValues(i),this.setKey(i,t)}setDefaultValues(e){this.schema.tableFields.forEach(t=>{void 0!==t.default&&(e[t.name]=t.default)})}copyProperties(e,t,i=!1){this.allFields.forEach(s=>{(i||this.cKeys.indexOf(s)<0&&s!==this.primaryKey)&&void 0!==t[s]&&(e[s]=t[s])})}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(2),n=i(6),r=i(1);var a;!function(e){e[e.Transient=-1]="Transient",e[e.Persistent=0]="Persistent",e[e.New=1]="New",e[e.Modified=2]="Modified",e[e.Deleted=3]="Deleted"}(a=t.EntityState||(t.EntityState={}));class o{constructor(e){this.tracker=e,this.log=r.LogManager.getLogger(o.name)}static isExtended(e){return e.hasOwnProperty("__schema__")&&e.hasOwnProperty("__state__")}static isProxied(e){return o.isExtended(e)}static convertToProxied(e){if(!o.isProxied(e))throw new Error("Invalid Proxied Entity");return e}static proxyToEntity(e,t=!0){return t?s.partial(e,e=>o.isNormalProperty(e)):s.partial(e,e=>"_version_"!==e&&o.isNormalProperty(e))}static isNormalProperty(e){return e.length<=4||e[0]!==e[1]||"_"!==e[0]||!e.endsWith("__")}attachExtendProperties(e,t,i,s){let n=Object.assign({_version_:1,__detached__:!1,__state__:i,__confirmed__:s,__schema__:t,__tracker__:this.tracker,__tracking__:!0,__changes__:null,__unconfirmedChanges__:null},e);return n._version_=n._version_||1,n}static initChanges(e,t=n.EntityChangeType.Modify){t===n.EntityChangeType.Modify&&(e.__changes__={type:n.EntityChangeType.Modify,dbVersion:e._version_,propertiesChanges:new Array({name:"_version_",original:e._version_-1,current:e._version_})}),e.__unconfirmedChanges__={type:t,dbVersion:e._version_,propertiesChanges:new Array}}getPropertyKeys(e){return e.__schema__.fieldNames}onPropertySet(e,t,i,s){const n=e,r=t.toString();if(!o.isNormalProperty(r)||!n.__tracking__||i===e[r])return e[r]=i,!0;if(n.__state__===a.Deleted||n.__state__===a.Transient)throw new Error("Can not modify property after deleted");let c=n.__schema__;if(c.isReadonly)throw new Error(`Can not modify readonly model '${c.modelName}'`);if(c.primaryKey===r||c.compositeKeys.indexOf(r)>=0)throw new Error("Can not modify primary key or composite key property");return n.__detached__&&(n.__tracker__.attach(s),n.__detached__=!1),o.recordPropertyChanges(n,t,i),e[r]=i,!0}static recordPropertyChanges(e,t,i){let s=!1;e.__tracker__.isConfirming&&e.__confirmed__&&(s=!0,e.__confirmed__=!1),e.__tracker__.isConfirming&&e.__tracker__.registerUnconfirmedEntity(e),e.__state__===a.Persistent&&(e._version_++,e.__state__=a.Modified,o.initChanges(e));let r=null;e.__state__===a.Modified?r=e.__confirmed__?e.__changes__.propertiesChanges:e.__unconfirmedChanges__.propertiesChanges:e.__state__===a.New&&e.__tracker__.isConfirming&&(s&&o.initChanges(e,n.EntityChangeType.New),r=null===e.__unconfirmedChanges__?void 0:e.__unconfirmedChanges__.propertiesChanges);let c=t.toString();r&&r.push({name:c,original:e[c],current:i})}static isDirty(e){const t=o.convertToProxied(e).__state__;return!(t===a.Persistent||t===a.Transient)}proxyNew(e,t,i){let s=this.attachExtendProperties(e,t,a.New,i);return new Proxy(s,{set:this.onPropertySet,ownKeys:this.getPropertyKeys})}proxyPersistent(e,t,i){let s=this.attachExtendProperties(e,t,a.Persistent,i);return new Proxy(s,{set:this.onPropertySet,ownKeys:this.getPropertyKeys})}confirmChanges(e){if(e.__confirmed__)return void(this.log.infoEnabled&&this.log.info("confirm when confirmed"));let t=e.__unconfirmedChanges__;t&&e.__changes__?e.__changes__.propertiesChanges.push(...t.propertiesChanges):e.__changes__||(e.__changes__=s.deepCopy(t)),e.__confirmed__=!0,e.__unconfirmedChanges__&&(e.__unconfirmedChanges__.propertiesChanges=new Array)}cancelChanges(e){e.__confirmed__?this.log.infoEnabled&&this.log.info("cancel when confirmed"):(e.__tracking__=!1,e.__unconfirmedChanges__&&e.__unconfirmedChanges__.propertiesChanges.forEach(t=>e[t.name]=t.original),e.__tracking__=!0,e.__state__===a.Modified&&(e.__state__=e.__changes__?a.Modified:a.Persistent),e.__confirmed__=!0,e.__unconfirmedChanges__&&(e.__unconfirmedChanges__.propertiesChanges=new Array))}}t.EntityProxy=o},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(11),n=i(7);class r{constructor(e){this.connection=e}async commit(){await this.connection.execute("COMMIT;")}async rollback(){await this.connection.execute("ROLLBACK;")}}t.SqliteConnection=class{constructor(e){this.options=e,this.sqlite=new s.SqliteWrapper}get connectionOptions(){return this.options}get isConnected(){return this.sqlite.isConnected}async connect(){return this.sqlite.asynOpen(this.options.storage)}async disconnect(){return await this.sqlite.asynClose()}async query(e,t){return await this.sqlite.asynQuery(e,t)}querySync(e,t){return this.sqlite.query(e,t)}ensureExecuteEffected(e){if(0===e.rowsEffected)throw new Error("None row effected")}executeBatchSync(e){return this.sqlite.executeBatch(e||[],this.ensureExecuteEffected)}async executeBatch(e){return await this.sqlite.asyncExecuteBatch(e||[],this.ensureExecuteEffected)}executeSync(e,t,i=!1){const s=this.sqlite.execute(e,t);return i&&this.ensureExecuteEffected(s),s}async execute(e,t,i=!1){const s=await this.sqlite.asynExecute(e,t);return i&&this.ensureExecuteEffected(s),s}async runScript(e){e.split(n.MULTI_SQL_SEPARATOR).forEach(async e=>await(""!==e.trim())&&this.sqlite.execute(e,[]))}async beginTrans(){return await this.execute("BEGIN TRANSACTION;"),new r(this)}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(3),n=i(2),r=i(0);var a;!function(e){e[e.New=1]="New",e[e.Modify=2]="Modify",e[e.Delete=3]="Delete"}(a=t.EntityChangeType||(t.EntityChangeType={}));t.BaseEntityTracker=class{constructor(e,t){this.log=t,this.cache=e,this.confirming=!1,this.history=new Map,this.minVersion=-1,this.currentVersion=-1}makeModelAndKey(e,t){let i={m:e.modelName,k:t};return JSON.stringify(i)}splitModelAndKey(e){let t=JSON.parse(e),i=r.isString(t.k)||r.isNumber(t.k)?t.k:new s.CompositeKey(t.k.keyObject);return{model:t.m,key:i}}attachHistory(e){if(this.log.infoEnabled&&this.log.info(`BEGIN attachHistory history info = ${JSON.stringify(this.historyVersion)}`),e.forEach((e,t)=>{let i=new Map;e.forEach(e=>i.set(e.modelAndKey,e.changes)),this.history.set(t,i),this.minVersion=this.minVersion<0?t:Math.min(t,this.minVersion),this.currentVersion=Math.max(t,this.currentVersion)}),this.log.infoEnabled){let t=new Array;e.forEach((e,i)=>t.push(i)),this.log.info(`SUCCESS attachHistory height = ${JSON.stringify(t)}`)}}get historyVersion(){return{min:this.minVersion,max:this.currentVersion}}getHistoryByVersion(e,t=!1){return!this.history.has(e)&&t&&this.history.set(e,new Map),this.history.get(e)}getChangesUntil(e){const t=new Array;let i=this.currentVersion;for(;i>=e;){let e=this.getHistoryByVersion(i);e&&t.push(e),i--}return t}rollbackCacheChanges(e,t,i){switch(i.type){case a.New:this.cache.evit(e,t);break;case a.Modify:let s=this.cache.get(e,t);if(void 0===s)return;i.propertiesChanges.forEach(e=>s[e.name]=e.original),this.cache.put(e,t,s);break;case a.Delete:const r=n.makeJsonObject(i.propertiesChanges,e=>e.name,e=>e.original);this.cache.put(e,t,r)}}clearHistoryBefore(e){if(!(this.minVersion>=e||this.currentVersion<e)){for(let t=this.minVersion;t<e;t++)this.history.delete(t);this.minVersion=e}}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(3),n=i(2),r=i(0),a=i(14)({separatedValues:!1}),o=i(13);var c;t.MULTI_SQL_SEPARATOR=";",function(e){e[e.Schema=0]="Schema",e[e.Select=1]="Select",e[e.Insert=2]="Insert",e[e.Update=3]="Update",e[e.Delete=4]="Delete",e[e.Other=9]="Other"}(c=t.SqlType||(t.SqlType={}));t.JsonSqlBuilder=class{getTableName(e){return o.snakeCase(e)+"s"}getPrimaryKeyCondition(e,t){return e.setKey({},t)}replaceJsonFields(e,t){if(0===e.jsonFields.length)return t;let i=Object.assign({},t);return e.jsonFields.forEach(e=>{Reflect.has(t,e)&&(i[e]=JSON.stringify(t[e]))}),i}buildSchema(e){let t=new Array,i=Object.assign({type:"create"},n.deepCopy(e.schemaObject));e.jsonFields.forEach(e=>i.tableFields.find(t=>t.name===e).type=s.FieldTypes.Text);let r=a.build(i);t.push(r.query);const o=this.getTableName(e.modelName);return e.indexes.forEach(e=>{t.push(a.build({type:"index",table:o,name:o+"_"+e,indexOn:e}).query)}),t}buildInsert(e,t){let i={type:c.Insert,get parameters(){return this.values}};return Object.assign(i,a.build({type:"insert",table:this.getTableName(e.modelName),values:this.replaceJsonFields(e,t)}))}buildDelete(e,t){let i={type:c.Delete,get parameters(){return this.values}};return Object.assign(i,a.build({type:"remove",table:this.getTableName(e.modelName),condition:this.getPrimaryKeyCondition(e,t)}))}buildUpdate(e,t,i,s){const n=this.getTableName(e.modelName);let r=this.getPrimaryKeyCondition(e,t);r._version_=s;let o={type:c.Update,get parameters(){return this.values}};return Object.assign(o,a.build({type:"update",table:n,modifier:this.replaceJsonFields(e,i),condition:r}))}buildSelect(e,t,i,s,n,o){const l=this.getTableName(e.modelName);let h;if(r.isArray(t)){let a=t||e.fieldNames.map(t=>e.schemaObject.table+"."+t),c=r.isNumber(s)?{limit:s}:s||{},d=n||{};for(let e of Reflect.ownKeys(d)){let t=d[e]||-1;d[e]="ASC"===t?1:"DESC"===t?-1:t}h={type:"select",table:l,fields:a,condition:i,limit:c.limit,offset:c.offset,sort:d,join:o}}else{let e=t;h=Object.assign({type:"select",table:l},e)}let d={type:c.Select,get parameters(){return this.values}};return Object.assign(d,a.build(h))}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(16),n=i(7),r=i(4),a=i(12),o=i(1),c=i(0);class l{constructor(e,t,i){this.log=o.LogManager.getLogger(l.name+(void 0===i?"":`_${i}`)),this.sessionSerial=-1,this.connection=e,this.models=new Map,this.sessionCache=new s.LRUEntityCache(t),this.sqlBuilder=new n.JsonSqlBuilder,this.entityTracker=new a.ProxiedEntityTracker(this.sessionCache),this.holdLocks=new Map,this.trackerSqlBuilder=new a.ProxiedTrackerSqlBuilder(this.entityTracker,this.models,this.sqlBuilder)}getSchemaByName(e){const t=this.models.get(e);if(!t)throw new Error(`unregistered model ( name = '${e}' )`);return t}getSchemaByClass(e){const t=this.models.get(e.name);if(!t)throw new Error(`unregistered model ( name = '${e.name}' )`);return t}getSchema(e){return c.isString(e)?this.getSchemaByName(e):this.getSchemaByClass(e)}makeByKeyCondition(e,t){return e.setKey({},t)}trackPersistentEntities(e,t,i=!0,s=!1){let n=new Array;return t.forEach(t=>{let r=e.getKey(t),a=this.entityTracker.getTrackingEntity(e,r),o=s&&void 0!==a?a:this.entityTracker.trackPersistent(e,t);n.push(o),i&&this.entityCache.put(e.modelName,r,t)}),n}reset(e=!1){this.entityTracker.stopTrackAll(),e&&this.entityCache.clear()}undefinedIfDeleted(e){return e.__state__===r.EntityState.Deleted||e.__state__===r.EntityState.Transient?void 0:e}get isOpen(){return this.connection&&this.connection.isConnected}get entityCache(){return this.sessionCache}syncSchema(e){this.sqlBuilder.buildSchema(e).forEach(e=>{this.connection.executeSync(e)})}registerSchema(...e){e.forEach(e=>this.models.set(e.modelName,e))}async close(){this.reset(!0),await this.connection.disconnect()}initRecentHistory(e){if(this.sessionSerial>=0)throw new Error("Session recent history exists already");let t=-1;[...e.keys()].forEach(e=>t=Math.max(t,e)),this.sessionSerial=t,this.attachHistory(e)}attachHistory(e){this.entityTracker.attachHistory(e)}getAllCached(e,t){const i=this.getSchema(e);let s=new Map;new Array(...this.entityTracker.trackingEntities).filter(e=>e.__schema__.modelName===i.modelName&&e.__state__!==r.EntityState.Deleted&&e.__state__!==r.EntityState.Transient).forEach(e=>s.set(this.entityTracker.getModelAndKey(e),e));let n=this.entityCache.getAll(i.modelName,t);return n&&n.forEach(e=>{let t=this.entityTracker.makeModelAndKey(i,i.getKey(e));if(!s.has(t)){let n=this.entityTracker.trackPersistent(i,e);s.set(t,n)}}),t?[...s.values()].filter(t):[...s.values()]}attach(e,t){let i=this.entityTracker.getTrackingEntity(e,t);if(void 0!==i)return this.undefinedIfDeleted(i);let s=this.entityCache.get(e.modelName,t);return void 0===s?void 0:this.entityTracker.trackPersistent(e,s)}async getAll(e,t=!1){const i=this.getSchema(e);if(i.memCached&&this.entityCache.existsModel(i.modelName)){let e=this.entityCache.getAll(i.modelName)||[];return t?this.trackPersistentEntities(i,e,!1,!0):e}return await this.getMany(e,{},t)}replaceJsonFields(e,t){if(0===e.jsonFields.length)return t;let i=Object.assign({},t);return e.jsonFields.forEach(e=>{Reflect.has(i,e)&&(i[e]=JSON.parse(t[e]))}),i}replaceEntitiesJsonFields(e,t){if(0===e.jsonFields.length)return t;for(let i=0;i<t.length;i++)t[i]=this.replaceJsonFields(e,t[i]);return t}async getMany(e,t,i=!1,s=!0){const n=this.getSchema(e),r=this.sqlBuilder.buildSelect(n,n.fieldNames,t);let a=this.replaceEntitiesJsonFields(n,await this.connection.query(r.query,r.parameters));return s&&a.forEach(e=>this.entityCache.put(n.modelName,n.getKey(e),e)),i?this.trackPersistentEntities(n,a,!1):a}async query(e,t,i,s,n,r){const a=this.getSchema(e),o=this.sqlBuilder.buildSelect(a,a.fieldNames,t,i,s,r);return this.replaceEntitiesJsonFields(a,await this.connection.query(o.query,o.parameters))}async queryByJson(e,t){const i=this.getSchema(e),s=this.sqlBuilder.buildSelect(i,t);return this.replaceEntitiesJsonFields(i,await this.connection.query(s.query,s.parameters))}async exists(e,t){const i=this.getSchema(e);let{query:s,parameters:r}=this.sqlBuilder.buildSelect(i,[],t);s=`select exists(${s.replace(n.MULTI_SQL_SEPARATOR,"")}) as exist`;const a=await this.connection.query(s,r);return c.isArray(a)&&parseInt(a[0].exist)>0}async count(e,t){let i=await this.queryByJson(e,{fields:"count(*) as count",condition:t});return c.isArray(i)?parseInt(i[0].count):0}create(e,t,i){if(!t)throw new Error("entity key can not be null or undefined");const s=this.getSchema(e);let n=s.newEntity(e,t);if(i&&s.copyProperties(n,i),void 0!==this.entityTracker.getTrackingEntity(s,t)||this.sessionCache.exists(s.modelName,t))throw new Error(`entity exists already ( model = '${s.modelName}' key = '${t}' )`);return this.entityTracker.trackNew(s,n)}async loadEntityByKey(e,t){const i=this.getSchemaByName(e),s=this.makeByKeyCondition(i,t),n=this.sqlBuilder.buildSelect(i,i.fieldNames,s),r=this.replaceEntitiesJsonFields(i,await this.connection.query(n.query,n.parameters));if(r.length>1)throw new Error(`entity key is duplicated ( model = '${e}' key = '${t}' )`);return 1===r.length?r[0]:void 0}async load(e,t){const i=this.loadCached(e,t,!0);if(void 0!==i)return i;const s=c.isString(e)?e:e.name,n=this.getSchemaByName(s);let r=this.entityTracker.getTrackingEntity(n,t);if(r)return this.undefinedIfDeleted(r);const a=await this.loadEntityByKey(s,t);return void 0!==a?(this.sessionCache.put(s,t,a),this.entityTracker.trackPersistent(this.getSchemaByName(s),a)):void 0}getChanges(){return this.entityTracker.getTrackingChanges()}loadCached(e,t,i=!1){const s=c.isString(e)?e:e.name,n=this.getSchemaByName(s),r=this.entityTracker.getTrackingEntity(n,t);if(r&&i)return this.undefinedIfDeleted(r);const a=this.sessionCache.get(s,t);return void 0!==a&&i?this.entityTracker.trackPersistent(n,a):a}lockInThisSession(e,t=!1){if(!this.holdLocks.has(e))return this.holdLocks.set(e,this.entityTracker.isConfirming),!0;if(!t)throw new Error(`${e} exists already`);return!1}async saveChanges(e){const t=e||++this.sessionSerial;this.log.traceEnabled&&this.log.trace(`BEGIN saveChanges ( serial = ${t} )`),this.entityTracker.isConfirming&&this.commitEntityTransaction();const i=this.trackerSqlBuilder.buildChangeSqls(),s=await this.connection.beginTrans();try{return await this.connection.executeBatch(i),await s.commit(),this.entityTracker.acceptChanges(t),this.holdLocks.clear(),this.sessionSerial=t,this.log.traceEnabled&&this.log.trace(`SUCCESS saveChanges ( serial = ${t} )`),t}catch(e){throw this.log.errorEnaled&&this.log.error(`FAILD saveChanges ( serial = ${t} )`,e),await s.rollback(),this.entityTracker.rejectChanges(),e}}async rollbackChanges(e){if(this.sessionSerial<e)return this.sessionSerial;const t=this.sessionSerial;this.log.traceEnabled&&this.log.trace(`BEGIN rollbackChanges ( serial = ${e} )`);const i=this.trackerSqlBuilder.buildRollbackChangeSqls(e+1),s=await this.connection.beginTrans();try{return await this.connection.executeBatch(i),await s.commit(),this.entityTracker.rollbackChanges(e+1),this.holdLocks.clear(),this.sessionSerial=e,this.log.traceEnabled&&this.log.trace(`SUCCESS rollbackChanges (serial : ${t} -> ${this.sessionSerial})`),this.sessionSerial}catch(e){throw this.log.errorEnaled&&this.log.error(`FAILD rollbackChanges (serial : ${t} -> ${this.sessionSerial})`,e),await s.rollback(),e}}clearHistoryBefore(e){return this.entityTracker.clearHistoryBefore(e)}get historyVersion(){return this.entityTracker.historyVersion}update(e){}delete(e){this.entityTracker.trackDelete(e.__schema__,e)}async beginTransaction(){return await this.connection.beginTrans()}beginEntityTransaction(){this.entityTracker.beginConfirm()}commitEntityTransaction(){this.entityTracker.confirm(),this.holdLocks.forEach((e,t)=>this.holdLocks[t]=!1)}rollbackEntityTransaction(){this.entityTracker.cancelConfirm();let e=new Array;this.holdLocks.forEach((t,i)=>t&&e.push(i)),e.forEach(e=>this.holdLocks.delete(e))}}t.DbSession=l},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.BlockCache=class{constructor(e){this.cache=new Map,this.minHeight=-1,this.maxHeight=-1,this.maxCachedCount=e}isCached(e){return e>0&&e>=this.minHeight&&e<=this.maxHeight}get cachedHeightRange(){return{min:this.minHeight,max:this.maxHeight}}push(e){if(this.maxHeight>=0&&e.height!==this.maxHeight+1)throw new Error(`invalid block height, expected : ${this.maxHeight+1} actual : ${e.height}`);this.cache.set(e.height,e),this.maxHeight=e.height,this.minHeight=-1===this.minHeight?e.height:this.minHeight,this.cache.size>=this.maxCachedCount&&this.cache.delete(this.minHeight++)}get(e){return this.cache.get(e)}getById(e){for(const t of this.cache.values())if(t.id===e)return t}evitUntil(e){if(e>this.maxHeight)return;const t=Math.max(e,this.minHeight);for(let e=t;e<=this.maxHeight;e++)this.cache.delete(e);this.minHeight=t===this.minHeight?-1:this.minHeight,this.maxHeight=-1===this.minHeight?-1:t}}},function(e,t){e.exports=require("better-sqlite3")},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(0),n=i(1),r=i(10);class a{constructor(){this.log=n.LogManager.getLogger(a.name)}open(e,t){let i={err:null,result:!0};try{this.db=new r(e),this.log.traceEnabled&&this.log.trace(`SUCCESS open ( db = ${e} )`)}catch(s){if(i={err:s,result:!1},this.log.errorEnaled&&this.log.error(`FAILD open ( db = ${e} )`,s),!t)throw s}return t&&t(i.err,i.result),i.result}get isConnected(){return this.db.open}async asynOpen(e){return s.promisify(this.open).call(this,e)}close(e){let t={err:null,result:!0};try{this.db&&this.isConnected?(this.db.close(),this.log.traceEnabled&&this.log.trace("SUCCESS close")):this.log.infoEnabled&&this.log.info("closed already")}catch(i){if(t={err:i,result:!1},this.log.errorEnaled&&this.log.error("FAILD close",i),!e)throw i}return e&&e(t.err,t.result),t.result}asynClose(){return s.promisify(this.close).call(this)}execute(e,t,i){let s={err:null,result:{lastInsertRowId:"0",rowsEffected:0}};try{const n=this.db.prepare(e).run(t||[]);s.result={lastInsertRowId:n.lastInsertROWID.toString(),rowsEffected:n.changes},this.log.traceEnabled&&this.log.trace(`SUCCESS execute sql = ${e} param = ${JSON.stringify(t)}, effected = ${s.result.rowsEffected}`)}catch(n){if(s.err=n,this.log.errorEnaled&&this.log.error(`FAILD execute sql = ${e} param = ${JSON.stringify(t)}`,n),!i)throw n}return i&&i(s.err,s.result),s.result}query(e,t,i){let s={err:null,result:new Array};try{s.result=this.db.prepare(e).all(t||[]),this.log.traceEnabled&&this.log.trace(`SUCCESS query sql = ${e} param = ${JSON.stringify(t)}, result count = ${s.result.length}`)}catch(n){if(s.err=n,this.log.errorEnaled&&this.log.error(`FAILD query sql = ${e} param = ${JSON.stringify(t)}`,n),!i)throw n}return i&&i(s.err,s.result),s.result}executeBatch(e,t,i){let s,n={err:null,result:new Array};try{e.forEach(e=>{s=e;let i=this.execute(e.query,e.parameters);t&&t(i,e),n.result.push(i)})}catch(e){if(n.err=e,this.log.errorEnaled&&this.log.error(`FAILD executeBatch, sql = ${s.query} param = ${JSON.stringify(s.parameters)}`,e),!i)throw e}return i&&i(n.err,n.result),n.result}async asynExecute(e,t){return s.promisify(this.execute).call(this,e,t)}async asynQuery(e,t){return s.promisify(this.query).call(this,e,t)}asyncExecuteBatch(e,t){return s.promisify(this.executeBatch).call(this,e,t)}}t.SqliteWrapper=a},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(1),n=i(6),r=i(2),a=i(4);class o extends n.BaseEntityTracker{constructor(e){super(e,s.LogManager.getLogger(o.name)),this.proxy=new a.EntityProxy(this),this.allTrackingEntities=new Map,this.unconfirmedEntities=new Map}ensureNoTracking(e,t){const i=this.makeModelAndKey(e,e.getKey(t));if(this.allTrackingEntities.has(i))throw new Error(`entity model=${e.modelName} key=${e.getKey(t)} is tracking`)}getModelAndKey(e){return this.makeModelAndKey(e.__schema__,e.__schema__.getKey(e))}saveHistory(e,t,i){this.getHistoryByVersion(i,!0).set(this.getModelAndKey(e),t)}removeTrackingTransisentEntities(){let e=new Array;this.allTrackingEntities.forEach((t,i)=>t.__state__===a.EntityState.Transient&&e.push(i)),e.forEach(e=>this.allTrackingEntities.delete(e))}attach(e){const t=this.makeModelAndKey(e.__schema__,e.__schema__.getKey(e));if(this.allTrackingEntities.has(t))throw new Error("exists another tracked entity");this.allTrackingEntities.set(this.getModelAndKey(e),e)}getLastChanges(e){if(a.EntityProxy.isDirty(e))switch(e.__state__){case a.EntityState.New:return this.createNewOrDeleteChanges(e,e._version_,!0);case a.EntityState.Deleted:return this.createNewOrDeleteChanges(e,e._version_,!1);case a.EntityState.Modified:return e.__changes__;default:return}}get trackingEntities(){return this.allTrackingEntities.values()}isTracking(e,t){return this.allTrackingEntities.has(this.makeModelAndKey(e,t))}registerUnconfirmedEntity(e){const t=this.getModelAndKey(e);this.unconfirmedEntities.set(t,e)}get isConfirming(){return this.confirming}beginConfirm(){this.confirming=!0,this.log.traceEnabled&&this.log.trace("BEGIN beginConfirm")}confirm(){this.unconfirmedEntities.forEach(e=>{e.__state__===a.EntityState.New?this.confirmNew(e):e.__state__===a.EntityState.Modified?this.confirmModify(e):e.__state__===a.EntityState.Deleted&&this.confirmedDelete(e)}),this.unconfirmedEntities.clear(),this.removeTrackingTransisentEntities(),this.confirming=!1,this.log.traceEnabled&&this.log.trace("SUCCESS confirm ")}cancelConfirm(){this.unconfirmedEntities.forEach(e=>{e.__state__===a.EntityState.New?this.cancelUnconfirmedNew(e):e.__state__===a.EntityState.Modified?this.cancelUnconfirmedModify(e):e.__state__===a.EntityState.Deleted?this.cancelUnconfirmedDelete(e):e.__state__===a.EntityState.Transient&&this.cancelUnconfirmedDelete(e)}),this.unconfirmedEntities.clear(),this.removeTrackingTransisentEntities(),this.confirming=!1,this.log.traceEnabled&&this.log.trace("SUCCESS cancelConfirm ")}getTrackingEntity(e,t){const i=this.makeModelAndKey(e,t);return this.allTrackingEntities.has(i)?this.allTrackingEntities.get(i):void 0}trackNew(e,t){this.ensureNoTracking(e,t);let i=this.proxy.proxyNew(t,e,!this.isConfirming);return this.allTrackingEntities.set(this.getModelAndKey(i),i),this.confirming&&this.registerUnconfirmedEntity(i),i}trackDelete(e,t){let i=a.EntityProxy.convertToProxied(t);if(i.__state__!==a.EntityState.Deleted&&i.__state__!==a.EntityState.Transient)switch(this.confirming&&this.registerUnconfirmedEntity(i),i.__confirmed__=!this.confirming,i.__state__){case a.EntityState.New:i.__state__=a.EntityState.Transient;break;case a.EntityState.Modified:case a.EntityState.Persistent:i.__state__=a.EntityState.Deleted}}confirmNew(e){e.__confirmed__=!0}cancelUnconfirmedNew(e){e.__unconfirmedChanges__&&e.__unconfirmedChanges__.type===n.EntityChangeType.New?this.proxy.cancelChanges(e):e.__state__=a.EntityState.Transient,e.__confirmed__=!0}confirmModify(e){this.proxy.confirmChanges(e)}cancelUnconfirmedModify(e){this.proxy.cancelChanges(e)}confirmedDelete(e){e.__confirmed__=!0}cancelUnconfirmedDelete(e){if(e.__state__===a.EntityState.Transient)e.__state__=a.EntityState.New;else if(e.__state__===a.EntityState.Deleted){let t=e.__changes__&&e.__changes__.propertiesChanges.length>0;e.__state__=t?a.EntityState.Modified:a.EntityState.Persistent}e.__unconfirmedChanges__&&(e.__unconfirmedChanges__.propertiesChanges=new Array),e.__confirmed__=!0}trackPersistent(e,t){this.ensureNoTracking(e,t);let i=this.proxy.proxyPersistent(t,e,!this.confirming);return this.allTrackingEntities.set(this.getModelAndKey(i),i),i}stopTrack(e,t){this.allTrackingEntities.delete(this.makeModelAndKey(e,e.getKey(t)))}stopTrackAll(){this.allTrackingEntities.clear()}getTrackingChanges(){let e=new Array;return this.allTrackingEntities.forEach(t=>{a.EntityProxy.isDirty(t)&&e.push({modelAndKey:this.getModelAndKey(t),changes:this.getLastChanges(t)})}),e}detectChanges(){let e=new Array;return this.allTrackingEntities.forEach(t=>{a.EntityProxy.isDirty(t)&&e.push({entity:t,changes:this.getLastChanges(t)})}),e}createNewOrDeleteChanges(e,t,i=!0){let s=new Array;for(const t in e)a.EntityProxy.isNormalProperty(t)&&s.push(i?{name:t,original:void 0,current:e[t]}:{name:t,original:e[t],current:void 0});return{type:i?n.EntityChangeType.New:n.EntityChangeType.Delete,dbVersion:t,propertiesChanges:s}}markStateAndSaveHistory(e,t){switch(e.__state__){case a.EntityState.New:this.log.traceEnabled&&this.log.trace(`NEW Version = ${t} entity = ${JSON.stringify(a.EntityProxy.proxyToEntity(e))}`),this.saveHistory(e,this.createNewOrDeleteChanges(e,e._version_,!0),t),e.__state__=a.EntityState.Persistent;break;case a.EntityState.Deleted:this.log.traceEnabled&&this.log.trace(`DELETE Version = ${t} entity = ${JSON.stringify(a.EntityProxy.proxyToEntity(e))}`),this.saveHistory(e,this.createNewOrDeleteChanges(e,e._version_,!1),t),e.__state__=a.EntityState.Transient;break;case a.EntityState.Modified:this.log.traceEnabled&&this.log.trace(`MODIFIED Version = ${t} changes = ${JSON.stringify(e.__changes__)} unconfirmed = ${JSON.stringify(e.__unconfirmedChanges__)}`),e.__state__=a.EntityState.Persistent,this.saveHistory(e,e.__changes__,t),e.__changes__=null;break;case a.EntityState.Persistent:case a.EntityState.Transient:}}acceptChanges(e){this.log.traceEnabled&&this.log.trace(`BEGIN acceptChanges Version = ${e}`),this.allTrackingEntities.forEach(t=>{const i=t.__schema__;t.__state__===a.EntityState.New||t.__state__===a.EntityState.Modified?this.cache.put(i.modelName,i.getKey(t),a.EntityProxy.proxyToEntity(t)):t.__state__===a.EntityState.Deleted&&this.cache.evit(i.modelName,i.getKey(t)),this.markStateAndSaveHistory(t,e),this.currentVersion=e,t.__detached__=!0}),this.allTrackingEntities.clear(),this.minVersion=-1===this.minVersion?e:this.minVersion,this.log.traceEnabled&&this.log.trace(`SUCCESS acceptChanges Version = ${e}`)}rejectChanges(){this.cancelConfirm(),this.allTrackingEntities.forEach(e=>{switch(e.__state__){case a.EntityState.New:e.__state__=a.EntityState.Transient;break;case a.EntityState.Modified:e.__tracking__=!1,e.__changes__.propertiesChanges.forEach(t=>e[t.name]=t.original),e.__tracking__=!0,e.__changes__=null,e.__state__=a.EntityState.Persistent;break;case a.EntityState.Deleted:e.__state__=a.EntityState.Persistent;break;case a.EntityState.Persistent:case a.EntityState.Transient:}}),this.log.traceEnabled&&this.log.trace("rejectChanges Version = ?")}rollbackChanges(e){const t=this.currentVersion;for(this.log.traceEnabled&&this.log.trace(`BEGIN rollbackChanges Version : ${t} -> ${e}`),this.rejectChanges();e<=this.currentVersion;){const e=this.getHistoryByVersion(this.currentVersion);e&&e.forEach((e,t)=>{const i=this.splitModelAndKey(t);this.rollbackCacheChanges(i.model,i.key,e)}),this.currentVersion--}this.allTrackingEntities.forEach(e=>e.__detached__=!0),this.allTrackingEntities.clear(),this.minVersion=Math.min(this.minVersion,this.currentVersion),this.log.traceEnabled&&this.log.trace(`SUCCESS rollbackChanges Version : ${t} -> ${this.currentVersion}`)}dumpChanges(e){let t="";return e.propertiesChanges.forEach(e=>t+=`${e.name}: ${e.original} -> ${e.current}, `),`dbVersion=${e.dbVersion}, type=${e.type}, [${t}]`}dumpHistory(){let e=this.currentVersion,t="--------------  DUMP HISTORY  ----------------\n\n";for(;e>=this.minVersion;){t+=`--------------version ${e}----------------\n`;let i=this.getHistoryByVersion(e);i&&i.forEach((e,i)=>{let s=this.dumpChanges(e);const n=this.splitModelAndKey(i),r=`type=${n.model}, key=${n.key}, changes={${s}} \n`;t+=r}),t+="\n",e--}return t+="--------------   END   DUMP  ----------------\n"}}t.ProxiedEntityTracker=o;t.ProxiedTrackerSqlBuilder=class{constructor(e,t,i){this.tracker=e,this.models=t,this.sqlBuilder=i}get entityTracker(){return this.tracker}buildChangeSqls(){let e=new Array;return this.tracker.detectChanges().forEach(t=>{e.push(this.buildSqlAndParameters(t.entity))}),e}buildSqlAndParameters(e){switch(e.__state__){case a.EntityState.New:const t=a.EntityProxy.proxyToEntity(e,!0);return this.sqlBuilder.buildInsert(e.__schema__,t);case a.EntityState.Modified:let i=this.tracker.getLastChanges(e),s=r.makeJsonObject(i.propertiesChanges,e=>e.name,e=>e.current);return this.sqlBuilder.buildUpdate(e.__schema__,e.__schema__.getKey(e),s,i.dbVersion-1);case a.EntityState.Deleted:return this.sqlBuilder.buildDelete(e.__schema__,e.__schema__.getKey(e));default:throw new Error(`Invalid entity state '${e.__state__}'`)}}buildRollbackChangeSqls(e){let t=new Array;return this.tracker.getChangesUntil(e).forEach(e=>e.forEach((e,i)=>{const s=this.tracker.splitModelAndKey(i),a=this.models.get(s.model);switch(e.type){case n.EntityChangeType.New:t.push(this.sqlBuilder.buildDelete(a,s.key));break;case n.EntityChangeType.Modify:let i=r.makeJsonObject(e.propertiesChanges,e=>e.name,e=>e.original);t.push(this.sqlBuilder.buildUpdate(a,s.key,i,e.dbVersion));break;case n.EntityChangeType.Delete:let o=r.makeJsonObject(e.propertiesChanges,e=>e.name,e=>e.original);t.push(this.sqlBuilder.buildInsert(a,o))}})),t}}},function(e,t){e.exports=require("change-case")},function(e,t){e.exports=require("json-sql")},function(e,t){e.exports=require("lru-cache")},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(15),n=i(2),r=i(1),a=i(0);class o{constructor(e){this.options=e||{default:o.DEFULT_MAX_CACHED_COUNT},this.log=r.LogManager.getLogger(o.name),this.modelCaches=new Map}getModelCache(e,t=!1,i=!1){if(t&&!this.modelCaches.has(e)){let t;t=this.options.hasOwnProperty(e)?a.isNumber(this.options[e])?Number(this.options[e]):a.isFunction(this.options[e])?this.options[e](e):o.DEFULT_MAX_CACHED_COUNT:this.options.default,t=Math.max(o.MIN_CACHED_COUNT,t),this.modelCaches.set(e,new s(t))}if(i&&!this.modelCaches.has(e))throw new Error(`Model cache ( name = '${e}' )  does not exists`);return this.modelCaches.get(e)}getCacheKey(e){return n.isPrimitiveKey(e)?e:e.key}clear(e){if(a.isString(e))return this.getModelCache(e,!1,!0).reset(),void this.modelCaches.delete(e);for(let e of this.modelCaches.values())e.reset();this.modelCaches.clear()}get models(){let e=new Array;for(let t of this.modelCaches.keys())e.push(t);return e}get(e,t){let i=this.getModelCache(e),s=this.getCacheKey(t);return this.modelCaches.has(e)&&i.has(s)?i.get(s):void 0}getAll(e,t){let i=new Array,s=this.getModelCache(e);if(void 0!==s)return s.forEach(e=>{(!t||t&&t(e))&&i.push(e)}),i}put(e,t,i){this.log.traceEnabled&&this.log.trace(`put cache, model = ${e}, key = ${t}, entity = ${JSON.stringify(i)}`),this.getModelCache(e,!0).set(this.getCacheKey(t),n.deepCopy(i))}evit(e,t){let i=this.getCacheKey(t);this.log.traceEnabled&&this.log.trace(`evit cache, model = ${e}, key = ${i}`);const s=this.getModelCache(e);s&&s.del(i)}exists(e,t){return void 0!==this.get(e,this.getCacheKey(t))}existsModel(e){return void 0!==this.getModelCache(e,!1,!1)}dumpCache(){let e="--------------  DUMP CACHE  ----------------\n\n";return this.modelCaches.forEach((t,i)=>{e+=`--------------Model ${i}----------------\n`,t.forEach((t,i)=>{e+=`key = ${this.getCacheKey(i)}, entity = {${JSON.stringify(t)}} \n`}),e+="\n"}),e+="--------------   END   DUMP  ----------------\n"}}o.MIN_CACHED_COUNT=100,o.DEFULT_MAX_CACHED_COUNT=1e4,t.LRUEntityCache=o},function(e,t){e.exports=require("level-secondary")},function(e,t){e.exports=require("level")},function(e,t){e.exports=require("level-sublevel")},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(0),n=i(19),r=i(18),a=i(17);function o(e){let t=null;return e||(t=(e=function(){let e,t=new Promise((t,i)=>{e=((e,s)=>e?i(e):t(s))});return e.promise=t,e}()).promise),{callback:e,promise:t}}t.SubLevelMeta=class{constructor(e,t,i=new Array){this.subName=e,this.keyField=t,this.indexFields=(new Array).concat(i)}findIndexOfFieldName(e){return this.indexFields.findIndex(t=>e===t.fieldName)}existsIndex(e){return this.findIndexOfFieldName(e)>-1}addIndex(e,t){if(this.existsIndex(e))throw new Error(`Index of field '${e}' already exists`);return this.indexFields.push({fieldName:e,calcIndex:t}),this}removeIndex(e){const t=this.findIndexOfFieldName(e);return t>-1&&this.indexFields.slice(t,1),this}};class c{constructor(e,t,i={}){this.dbDir=e,this.subMetas=(new Array).concat(t),this.subLevels=new Map,this.leveldb=null}async init(){this.leveldb=r(this.dbDir,{valueEncoding:"json"}),this.subLeveldb=n(this.leveldb),this.subMetas.forEach(e=>this.registerSubLevel(e))}registerSubLevel(e){const t=this.subLeveldb.sublevel(e.subName),i=new l(t,e.subName,e.keyField,...e.indexFields);this.subLevels.set(e.subName,i)}static isKeyNotFoundError(e){return e&&"NotFoundError"===e.name}get level(){return this.leveldb}getSubLevel(e){const t=this.subLevels.get(e);if(!t)throw new Error(`No such subLevel name = '${e}'`);return t}open(e){let t=this,{callback:i,promise:s}=o(e);return this.isOpen?(process.nextTick(i,null,t),s):((async()=>{try{await this.init(),process.nextTick(i,null,t)}catch(e){process.nextTick(i,e,t)}})(),s)}close(e){let t=this,{callback:i,promise:s}=o(e);return this.isClosed?(process.nextTick(i,null,t),s):((async()=>{try{await this.leveldb.close(),this.leveldb=null,process.nextTick(i,null,t)}catch(e){process.nextTick(i,e)}})(),s)}get isOpen(){return this.leveldb&&this.leveldb.isOpen()}get isClosed(){return!this.leveldb||this.leveldb.isClosed()}dump(){return new Promise((e,t)=>{let i=new Array;this.leveldb.createReadStream().on("data",e=>i.push(`key= ${e.key}, value= ${e.value}`)).on("error",e=>t(e)).on("end",()=>e(i.join("\r\n")))})}}t.LevelDB=c;class l{get name(){return this.subName}get indexes(){return this.indexArray}constructor(e,t,i,...s){this.subLevelDb=e,this.subName=t,this.keyField=i,this.indexArray=(new Array).concat(...s),this.indexedSubLevels=new Map,this.indexArray.forEach(t=>{let i=a(e,t.fieldName,t.calcIndex);this.indexedSubLevels.set(t.fieldName,i)})}get key(){return this.keyField}keyNotFoundThenUndefined(e){return e?(t,i)=>{e(c.isKeyNotFoundError(t)?null:t,i)}:void 0}async get(e,t,i){const s=this.subLevelDb;let{callback:n,promise:r}=o(i);try{s.get(e,t,this.keyNotFoundThenUndefined(n))}catch(e){n(c.isKeyNotFoundError(e)?void 0:e,void 0)}return r}byIndex(e){const t=this.indexedSubLevels.get(e);if(!t)throw new Error(`No such index field = '${e}'`);return t}async getBy(e,t,i){const s=this.byIndex(e);let{callback:n,promise:r}=o(i);try{s.get(t,this.keyNotFoundThenUndefined(n))}catch(e){n(c.isKeyNotFoundError(e)?void 0:e,void 0)}return r}async put(e,t,i){let{callback:s,promise:n}=o(i);try{this.subLevelDb.put(e,t,s)}catch(e){s(e,void 0)}return n}async del(e,t){let{callback:i,promise:s}=o(t);try{this.subLevelDb.del(e,i)}catch(e){i(e,void 0)}return s}async batch(e,t,i){if(0===arguments.length)return this.subLevelDb.batch();let n=t&&!s.isFunction(t),r=n?i:t,{callback:a,promise:c}=o(r);try{n?this.subLevelDb.batch(e,t,a):this.subLevelDb.batch(e,a)}catch(e){a(e,void 0)}return c}createReadStream(e){return this.subLevelDb.createReadStream(e)}createKeyStream(e){return this.subLevelDb.createKeyStream(e)}createValueStream(e){return this.subLevelDb.createValueStream(e)}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(20),n="__last_block_height__";t.LevelBlock=class{constructor(e,t={}){const i=new s.SubLevelMeta("blk","height",[{fieldName:"id"},{fieldName:"delegate"}]),n=new s.SubLevelMeta("his","height",[]);this.db=new s.LevelDB(e,[i,n],t),this.lastHeight=-1}async getLastBlockHeightFromDb(){let e=await this.blockDb.get(n,{});return void 0===e&&(e=this.getLastHeightJson(-1),await this.blockDb.put(n,e)),e.height}async open(){await this.db.open(),this.blockDb=this.db.getSubLevel("blk"),this.historyDb=this.db.getSubLevel("his"),this.lastHeight=await this.getLastBlockHeightFromDb()}async close(){await this.db.close()}get lastBlockHeight(){return this.lastHeight}isKeyNotFoundError(e){return"NotFoundError"===e.name}getLastHeightJson(e){return{height:e,id:"NULL",delegate:"NULL"}}async appendBlock(e,t){if(!e||!e.id||!e.delegate||void 0===e.height)throw new Error("Invalid block data");await this.historyDb.put(e.height,t),await this.blockDb.batch([{type:"put",key:e.height,value:e},{type:"put",key:n,value:this.getLastHeightJson(e.height)}]),this.lastHeight=e.height}async getBlock(e){try{return await this.blockDb.get(e)}catch(e){if(!this.isKeyNotFoundError(e))throw e}}async getHistoryChanges(e,t){let i=new Map;for(let s=e;s<=t;s++){const e=await this.historyDb.get(s);e&&i.set(s,e)}return i}async deleteLastBlock(e){if(e!==this.lastBlockHeight)throw new Error(`invalid last block height '${e}'`);await this.blockDb.batch([{type:"del",key:e},{type:"put",key:n,value:this.getLastHeightJson(e-1)}]),await this.historyDb.del(e),this.lastHeight--}async getBlockById(e){return await this.blockDb.getBy("id",e)}async getBlocksByHeightRange(e,t){let i=new Array;for(let s=e;s<=t;s++){let e=await this.getBlock(s);e&&i.push(e)}return i}async getBlocksByIds(e){let t=new Array;for(let i=0;i<e.length;i++){let s=await this.getBlockById(e[i]);s&&t.push(s)}return t}}},function(e,t){e.exports=require("events")},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(22),n=i(0),r=i(2),a=i(21),o=i(8),c=i(5),l=i(3),h=i(1),d=i(4),g=i(9);class u extends s.EventEmitter{constructor(e,t,i){r.CodeContract.argument("dbPath",()=>r.CodeContract.notNullOrWhitespace(e)),r.CodeContract.argument("levelBlockDir",()=>r.CodeContract.notNullOrWhitespace(t)),super(),this.options={cachedBlockCount:10,historyForRollback:10,autoCleanPersistedHistory:!1,entityCacheOptions:{default:5e3}}||i,this.commitBlockHooks=new Array,this.rollbackBlockHooks=new Array,this.schemas=new Map,this.log=h.LogManager.getLogger(u.name),this.blockDB=new a.LevelBlock(t),this.cachedBlocks=new g.BlockCache(this.options.cachedBlockCount),this.connection=new c.SqliteConnection({storage:e}),this.blockSession=new o.DbSession(this.connection,this.options.entityCacheOptions,"Block"),this.localSession=new o.DbSession(this.connection,this.options.entityCacheOptions,"Local")}getSchema(e,t=!1,i=!1){const s=n.isString(e)?String(e):e.name;let a=this.schemas.get(s);return t&&r.CodeContract.verify(void 0!==a,`unregistered model '${s}'`),i&&r.CodeContract.verify(!a.isReadonly,`model '${s}' is readonly`),a}getSession(e){return e.isLocal?this.localSession:this.blockSession}preCommitBlock(e){this.commitBlockHooks.forEach(t=>t.hook(e))}postCommitBlock(e){this.emit("newBlock",e)}preRollbackBlock(e,t){this.rollbackBlockHooks.forEach(i=>i.hook(e,t))}postRollbackBlock(e,t){this.emit("rollbackBlock",{from:e,to:t})}registerCommitBlockHook(e,t){r.CodeContract.argument("hookFunc",()=>r.CodeContract.notNull(t)),r.CodeContract.argument("name",()=>r.CodeContract.notNullOrWhitespace(e)),r.CodeContract.argument("name",void 0===this.commitBlockHooks.find(t=>t.name===e.trim()),`hook named '${e}' exist already`),this.commitBlockHooks.push({name:e,hook:t})}unregisterCommitBlockHook(e){r.CodeContract.argument("name",()=>r.CodeContract.notNullOrWhitespace(e));let t=this.commitBlockHooks.findIndex(t=>t.name===e.trim());t>=0&&this.commitBlockHooks.slice(t)}registerRollbackBlockHook(e,t){r.CodeContract.argument("hookFunc",()=>r.CodeContract.notNull(t)),r.CodeContract.argument("name",()=>r.CodeContract.notNullOrWhitespace(e)),r.CodeContract.argument("name",void 0===this.rollbackBlockHooks.find(t=>t.name===e.trim()),`hook named '${e}' exist already`),this.rollbackBlockHooks.push({name:e,hook:t})}unregisterRollbackBlockHook(e){r.CodeContract.argument("name",()=>r.CodeContract.notNullOrWhitespace(e));let t=this.rollbackBlockHooks.findIndex(t=>t.name===e.trim());t>=0&&this.rollbackBlockHooks.slice(t)}async init(e){r.CodeContract.argument("schemas",()=>r.CodeContract.notNull(e)),await this.connection.connect(),await this.blockDB.open();let t=await this.blockDB.getHistoryChanges(this.lastBlockHeight,this.lastBlockHeight);this.blockSession.initRecentHistory(t),await this.syncSchemas(e),await this.ensureLastBlockLoaded(),this.emit("ready",this)}async syncSchemas(e){for(const t of e){this.schemas.set(t.modelName,t);let e=this.getSession(t);if(e.registerSchema(t),e.syncSchema(t),this.log.infoEnabled&&this.log.info(`sync schema model = ${t.modelName} `),t.memCached){let i=await e.getMany(t.modelName,{},!1,!0);this.log.infoEnabled&&this.log.info(`model ${t.modelName} cached ${i.length} entities `)}}}async close(){await this.blockSession.close(),await this.localSession.close(),await this.blockDB.close(),this.emit("closed",this)}get lastBlockHeight(){return this.blockDB.lastBlockHeight}get blocksCount(){return this.lastBlockHeight+1}get lastBlock(){return this.cachedBlocks.get(this.lastBlockHeight)}lockInCurrentBlock(e,t=!1){return this.blockSession.lockInThisSession(e,t)}beginContract(){this.blockSession.beginEntityTransaction()}commitContract(){this.blockSession.commitEntityTransaction()}rollbackContract(){this.blockSession.rollbackEntityTransaction()}beginBlock(e){r.CodeContract.argument("block",()=>r.CodeContract.notNull(e)),r.CodeContract.argument("block",e.height===this.lastBlockHeight+1,`invalid block height ${e.height}, last = ${this.lastBlockHeight}`),this.log.infoEnabled&&this.log.info(`BEGIN block height = ${e.height}`),this.currentBlock=e}async commitBlock(){if(!this.currentBlock)throw new Error("Current block is null");this.log.traceEnabled&&this.log.trace(`BEGIN commitBlock height = ${this.currentBlock.height}`),this.preCommitBlock(this.currentBlock);let e=Object.assign({},this.currentBlock);Reflect.deleteProperty(e,"transactions"),await this.blockDB.appendBlock(e,this.blockSession.getChanges());try{return await this.blockSession.saveChanges(this.currentBlock.height),this.blockSession.clearHistoryBefore(this.currentBlock.height-this.options.historyForRollback),this.cachedBlocks.push(this.currentBlock),this.currentBlock=null,this.postCommitBlock(this.lastBlock),this.log.infoEnabled&&this.log.info(`SUCCESS commitBlock height = ${this.lastBlockHeight}`),this.lastBlockHeight}catch(e){throw this.log.errorEnaled&&this.log.error(`FAILD commitBlock ( height = ${this.currentBlock.height} )`,e),await this.blockDB.deleteLastBlock(this.currentBlock.height),e}}async rollbackBlock(e){r.CodeContract.argument("height",!e||e<=this.lastBlockHeight,`height must less or equal lastBlockHeight ${this.lastBlockHeight}`);const t=this.currentBlock?this.currentBlock.height:this.lastBlockHeight,i=void 0===e?this.lastBlockHeight:e;this.log.traceEnabled&&this.log.trace(`BEGIN rollbackBlock ( height : ${t} -> ${i} )`),this.preRollbackBlock(t,i);try{const e=this.blockSession.historyVersion;if(i<e.min){let t=await this.blockDB.getHistoryChanges(i,e.min);this.blockSession.attachHistory(t)}for(await this.blockSession.rollbackChanges(i);this.lastBlockHeight>i;)await this.blockDB.deleteLastBlock(this.lastBlockHeight),this.cachedBlocks.evitUntil(this.lastBlockHeight);await this.ensureLastBlockLoaded(),this.currentBlock=null,this.postRollbackBlock(t,i),this.log.infoEnabled&&this.log.info(`SUCCESS rollbackBlock ( height : ${t} -> ${i} )`)}catch(e){throw this.log.errorEnaled&&this.log.error(`FAILD rollbackBlock ( height : ${t} -> ${i} )`,e),e}}async saveLocalChanges(){let e=await this.localSession.saveChanges();return this.localSession.clearHistoryBefore(e),e}async rollbackLocalChanges(e){r.CodeContract.argument("serial",e>=0,"serial must great or equal zero"),await this.localSession.rollbackChanges(e),this.localSession.clearHistoryBefore(e)}getEntityKey(e,t){return r.CodeContract.argument("model",()=>r.CodeContract.notNull(e)),r.CodeContract.argument("entity",()=>r.CodeContract.notNull(t)),this.getSchema(e,!0).getKey(t)}async attach(e,t){r.CodeContract.argument("model",()=>r.CodeContract.notNull(e)),r.CodeContract.argument("entity",()=>r.CodeContract.notNull(t));let i=this.getEntityKey(e,t);r.CodeContract.argument("entity",void 0!==i,"can not get entity key");let s=this.getSchema(e,!0,!0);return this.getSession(s).load(e,i)}create(e,t){let i,s;r.CodeContract.argument("model",()=>r.CodeContract.notNull(e)),r.CodeContract.argument("keyOrEntity",()=>r.CodeContract.notNull(t));let n=this.getSchema(e,!0,!0);return r.isPrimitiveKey(t)||l.isCompositeKey(t)?i=t:(s=t,i=n.getKey(s)),this.getSession(n).create(e,i,s)}del(e,t){r.CodeContract.argument("model",()=>r.CodeContract.notNull(e)),r.CodeContract.argument("entity",t&&d.EntityProxy.isProxied(t),"is not a tracking entity");let i=this.getSchema(e,!0,!0);this.getSession(i).delete(t)}async get(e,t){r.CodeContract.argument("model",()=>r.CodeContract.notNull(e)),r.CodeContract.argument("key",()=>r.CodeContract.notNull(t));let i=this.getSchema(e,!0);return await this.getSession(i).load(e,t)}async getBy(e,t){r.CodeContract.argument("model",()=>r.CodeContract.notNull(e)),r.CodeContract.argument("condition",()=>r.CodeContract.notNull(t));let i=this.getSchema(e,!0),s=this.getSession(i),n=await s.getMany(e,t,!1,!0);if(n.length>1)throw new Error(`many entities found ( model = '${i.modelName}', condition = '${JSON.stringify(t)}' )`);return 0===n.length?void 0:this.attach(e,n[0])}async getMany(e,t,i=!1){r.CodeContract.argument("model",()=>r.CodeContract.notNull(e));let s=this.getSchema(e,!0);return await this.getSession(s).getMany(e,t,i)}getCached(e,t){r.CodeContract.argument("model",()=>r.CodeContract.notNull(e)),r.CodeContract.argument("key",()=>r.CodeContract.notNull(t));let i=this.getSchema(e,!0);return this.getSession(i).loadCached(e,t,!0)}getAllCached(e,t){r.CodeContract.argument("model",()=>r.CodeContract.notNull(e));let i=this.getSchema(e,!0);return this.getSession(i).getAllCached(e,t)}async find(e,t,i,s,n,a){r.CodeContract.argument("model",()=>r.CodeContract.notNull(e));let o=this.getSchema(e,!0);return await this.getSession(o).query(e,t,i,s,n,a)}async findOne(e,t){let i=await this.findAll(e,t),s=this.getSchema(e,!0);if(i.length>1)throw new Error(`many entities found ( model = '${s.modelName}' , params = '${JSON.stringify(t)}' )`);return 0===i.length?void 0:i[0]}async findAll(e,t){r.CodeContract.argument("model",()=>r.CodeContract.notNull(e));let i=this.getSchema(e,!0);return await this.getSession(i).queryByJson(e,t)}async exists(e,t){r.CodeContract.argument("model",()=>r.CodeContract.notNull(e));let i=this.getSchema(e,!0);return await this.getSession(i).exists(e,t)}async count(e,t){r.CodeContract.argument("model",()=>r.CodeContract.notNull(e));let i=this.getSchema(e,!0);return await this.getSession(i).count(e,t)}async ensureLastBlockLoaded(){if(void 0===this.lastBlock&&this.lastBlockHeight>=0){let e=await this.getBlockByHeight(this.lastBlockHeight,!0);this.log.infoEnabled&&this.log.info(`SUCCESS load last block (height = ${e.height}, id = '${e.id}')`),this.cachedBlocks.push(e)}}async attachTransactions(e,t){let i=new Map;return(await t()).forEach(e=>{i.has(e.height)||i.set(e.height,new Array),i.get(e.height).push(e)}),e.forEach(e=>e.transactions=i.get(e.height)||new Array),e}copyCachedBlock(e,t){let i=e();if(void 0===i)return;let s=Object.assign({},i);return t||Reflect.deleteProperty(s,"transactions"),s}async getBlockByHeight(e,t=!1){r.CodeContract.argument("height",e>=0,"height must great or equal zero");let i=this.copyCachedBlock(()=>this.cachedBlocks.get(e),t);if(i)return i;let s=await this.blockDB.getBlock(e);return t&&void 0!==s?(await this.attachTransactions([s],async()=>await this.blockSession.query("Transaction",{height:s.height})))[0]:s}async getBlockById(e,t=!1){r.CodeContract.argument("blockId",()=>r.CodeContract.notNullOrWhitespace(e));let i=this.copyCachedBlock(()=>this.cachedBlocks.getById(e),t);if(i)return i;let s=await this.blockDB.getBlockById(e);return t&&void 0!==s?(await this.attachTransactions([s],async()=>await this.blockSession.query("Transaction",{height:s.height})))[0]:s}async getBlocksByHeightRange(e,t,i=!1){r.CodeContract.argument("minHeight, maxHeight",e>=0&&t>=e,"minHeight or maxHeight is invalid");let s=await this.blockDB.getBlocksByHeightRange(e,t);return i?await this.attachTransactions(s,async()=>await this.blockSession.query("Transaction",{height:{$in:s.map(e=>e.height)}})):s}async getBlocksByIds(e,t=!1){r.CodeContract.argument("blockIds",()=>r.CodeContract.notNull(e));let i=await this.blockDB.getBlocksByIds(e);return t?await this.attachTransactions(i,async()=>await this.blockSession.query("Transaction",{height:{$in:i.map(e=>e.height)}})):i}}t.SmartDB=u},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(23),n=i(3),r=i(8),a=i(5),o=i(1);!function(e){e.SmartDB=s.SmartDB,e.ModelSchema=n.ModelSchema,e.LogManager=o.LogManager,e.LogLevel=o.LogLevel,e.DbSession=r.DbSession,e.SqliteConnection=a.SqliteConnection}(t.AschCore||(t.AschCore={}))}]);