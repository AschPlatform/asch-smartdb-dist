module.exports=function(e){var t={};function i(s){if(t[s])return t[s].exports;var r=t[s]={i:s,l:!1,exports:{}};return e[s].call(r.exports,r,r.exports,i),r.l=!0,r.exports}return i.m=e,i.c=t,i.d=function(e,t,s){i.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:s})},i.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i.w={},i(i.s=27)}([function(e,t){e.exports=require("util")},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(0);t.makeJsonObject=function(e,t,i){n.argument("iterable",()=>n.notNull(e)),n.argument("getKey",()=>n.notNull(t)),n.argument("getValue",()=>n.notNull(i));let s={};for(let r of e)s[t(r)]=i(r);return s},t.deepCopy=function(e){return e?JSON.parse(JSON.stringify(e)):e},t.partialCopy=function(e,t,i){n.argument("src",()=>n.notNull(e)),n.argument("keysOrKeyFilter",()=>n.notNull(t));let r=s.isFunction(t)?Object.keys(e).filter(t):t,a=i||{};for(let t of r)Reflect.has(e,t)&&(a[t]=e[t]);return a},t.isPrimitiveKey=function(e){return!!e&&(s.isString(e)||s.isNumber(e))};t.NotImplementError=class extends Error{constructor(e){super(e)}};class r extends Error{constructor(e){super(`Code contract Error, ${e}`)}}t.CodeContractError=r;class n{static verify(e,t){if(void 0===e||null===e)throw new Error("Invalid verify condition");const i=s.isFunction(e)?e():e,n=s.isFunction(t)?t():t;if(!i)throw new r(n)}static argument(e,t,i){if(!e||!t)throw new Error("argName or verify can not be null or undefined");if(i)n.verify(t,i);else{const i=t();n.verify(i.result,`argument '${e}' ${i.message}`)}}static notNull(e){const t=null!==e&&void 0!==e;return{result:t,message:t?void 0:"cannot be null or undefined"}}static notNullOrEmpty(e){const t=n.notNull(e)&&""!==e;return{result:t,message:t?void 0:"cannot be null or undefined or empty"}}static notNullOrWhitespace(e){const t=n.notNullOrEmpty(e)&&""!==e.trim();return{result:t,message:t?void 0:"cannot be null or undefined or whitespace"}}}t.CodeContract=n},function(e,t,i){"use strict";var s;Object.defineProperty(t,"__esModule",{value:!0}),function(e){e[e.All=127]="All",e[e.Trace=64]="Trace",e[e.Debug=32]="Debug",e[e.Log=16]="Log",e[e.Info=8]="Info",e[e.Warn=4]="Warn",e[e.Error=2]="Error",e[e.Fatal=1]="Fatal",e[e.None=0]="None"}(s=t.LogLevel||(t.LogLevel={}));class r{get infoEnabled(){return this.level>=s.Info}get traceEnabled(){return this.level>=s.Trace}get debugEnabled(){return this.level>=s.Debug}get logEnabled(){return this.level>=s.Log}get warnEnabled(){return this.level>=s.Warn}get errorEnaled(){return this.level>=s.Error}get fatalEnabled(){return this.level>=s.Fatal}get logLevel(){return this.level}set logLevel(e){this.level=e}constructor(e,t,i,s){this.name=e,this.level=s,this.format=i,this.logger=t}fromatMessage(e,t){return`${(new Date).toLocaleTimeString()} [${t}] [${this.name}] ${e}`}info(e,...t){e=this.format?this.fromatMessage(e,"INFO"):`[${this.name}] ${e}`,this.logger.info(e,...t)}debug(e,...t){e=this.format?this.fromatMessage(e,"DEBUG"):`[${this.name}] ${e}`,this.logger.debug(e,...t)}log(e,...t){e=this.format?this.fromatMessage(e,"LOG"):`[${this.name}] ${e}`,this.logger.debug(e,...t)}trace(e,...t){e=this.format?this.fromatMessage(e,"TRACE"):`[${this.name}] ${e}`,this.logger.debug(e,...t)}warn(e,...t){e=this.format?this.fromatMessage(e,"WARN"):`[${this.name}] ${e}`,this.logger.warn(e,...t)}error(e,t){e=this.format?this.fromatMessage(e,"ERROR"):`[${this.name}] ${e}`,this.logger.error(e,t)}fatal(e,t){e=this.format?this.fromatMessage(e,"FATAL"):`[${this.name}] ${e}`,this.logger.error(e,t)}}class n{static get defaultLogger(){return n.consoleLogger=n.consoleLogger||new r("default",console,!0,n.defaultLogLevel),n.consoleLogger}static set defaultLevel(e){n.defaultLogLevel=e}static get logFactory(){return n.factory}static set logFactory(e){n.factory=e}static getLogger(e){if(!n.factory)return n.defaultLogger;const t=n.factory.createLog(e),i=n.factory.getLevel(),s=n.factory.format;return new r(e||"",t,s,i)}}n.defaultLogLevel=s.All,n.factory={createLog:e=>console,format:!0,getLevel:()=>n.defaultLogLevel},t.LogManager=n},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(17);class r{constructor(){this.doTime=(e=>{this.traceName=e,this.uptime=process.uptime()}),this.doEndtime=(e=>{const t=process.uptime();console.log(`${this.traceName} cost ${t-this.uptime} s`),e&&(this.uptime=t)}),this.doRestartTime=(e=>{this.doEndtime(!0),this.traceName=e})}get time(){return this.isEnabled?this.doTime:e=>{}}get endTime(){return this.isEnabled?this.doEndtime:e=>{}}get restartTime(){return this.isEnabled?this.doRestartTime:e=>{}}get enabled(){return this.isEnabled}set enabled(e){this.isEnabled=e}}t.PerformanceHelper=r;class n{static get Array(){return n._array}static get String(){return n._string}static get Collection(){return n._collection}static get Function(){return n._function}static get Object(){return n._object}static get Lang(){return n._lang}static get Performace(){return n._performance}}n._performance=new r,n._array={chunk:s.chunk,compact:s.compact,concat:s.concat,difference:s.difference,differenceBy:s.differenceBy,differenceWith:s.differenceWith,drop:s.drop,dropRight:s.dropRight,dropRightWhile:s.dropRightWhile,dropWhile:s.dropWhile,fill:s.fill,findIndex:s.findIndex,findLastIndex:s.findLastIndex,first:s.first,head:s.head,flatten:s.flatten,flattenDeep:s.flattenDeep,flattenDepth:s.flattenDepth,fromPairs:s.fromPairs,indexOf:s.indexOf,initial:s.initial,intersection:s.intersection,intersectionBy:s.intersectionBy,intersectionWith:s.intersectionWith,join:s.join,last:s.last,lastIndexOf:s.lastIndexOf,nth:s.nth,pull:s.pull,pullAll:s.pullAll,pullAllBy:s.pullAllBy,pullAllWith:s.pullAllWith,pullAt:s.pullAt,remove:s.remove,reverse:s.reverse,slice:s.slice,sortedIndex:s.sortedIndex,sortedIndexBy:s.sortedIndexBy,sortedIndexOf:s.sortedIndexOf,sortedLastIndex:s.sortedLastIndex,sortedLastIndexBy:s.sortedLastIndexBy,sortedLastIndexOf:s.sortedLastIndexOf,sortedUniq:s.sortedUniq,sortedUniqBy:s.sortedUniqBy,tail:s.tail,take:s.take,takeRight:s.takeRight,takeRightWhile:s.takeRightWhile,takeWhile:s.takeWhile,union:s.union,unionBy:s.unionBy,unionWith:s.unionWith,uniq:s.uniq,uniqBy:s.uniqBy,uniqWith:s.uniqWith,unzip:s.unzip,unzipWith:s.unzipWith,without:s.without,xor:s.xor,xorBy:s.xorBy,xorWith:s.xorWith,zip:s.zip,zipObject:s.zipObject,zipObjectDeep:s.zipObjectDeep,zipWith:s.zipWith},n._lang={castArray:s.castArray,clone:s.clone,cloneDeep:s.cloneDeep,cloneDeepWith:s.cloneDeepWith,cloneWith:s.cloneWith,conformsTo:s.conformsTo,eq:s.eq,gt:s.gt,gte:s.gte,isArguments:s.isArguments,isArray:s.isArray,isArrayBuffer:s.isArrayBuffer,isArrayLike:s.isArrayLike,isArrayLikeObject:s.isArrayLikeObject,isBoolean:s.isBoolean,isBuffer:s.isBuffer,isDate:s.isDate,isElement:s.isElement,isEmpty:s.isEmpty,isEqual:s.isEqual,isEqualWith:s.isEqualWith,isError:s.isError,isFinite:s.isFinite,isFunction:s.isFunction,isInteger:s.isInteger,isLength:s.isLength,isMap:s.isMap,isMatch:s.isMatch,isMatchWith:s.isMatchWith,isNaN:s.isNaN,isNative:s.isNative,isNil:s.isNil,isNull:s.isNull,isNumber:s.isNumber,isObject:s.isObject,isObjectLike:s.isObjectLike,isPlainObject:s.isPlainObject,isRegExp:s.isRegExp,isSafeInteger:s.isSafeInteger,isSet:s.isSet,isString:s.isString,isSymbol:s.isSymbol,isTypedArray:s.isTypedArray,isUndefined:s.isUndefined,isWeakMap:s.isWeakMap,isWeakSet:s.isWeakSet,lt:s.lt,lte:s.lte,toArray:s.toArray,toFinite:s.toFinite,toInteger:s.toInteger,toLength:s.toLength,toNumber:s.toNumber,toPlainObject:s.toPlainObject,toSafeInteger:s.toSafeInteger,toString:s.toString},n._collection={countBy:s.countBy,each:s.each,eachRight:s.eachRight,every:s.every,filter:s.filter,find:s.find,findLast:s.findLast,flatMap:s.flatMap,flatMapDeep:s.flatMapDeep,flatMapDepth:s.flatMapDepth,forEach:s.forEach,forEachRight:s.forEachRight,groupBy:s.groupBy,includes:s.includes,invokeMap:s.invokeMap,keyBy:s.keyBy,map:s.map,orderBy:s.orderBy,partition:s.partition,reduce:s.reduce,reduceRight:s.reduceRight,reject:s.reject,sample:s.sample,sampleSize:s.sampleSize,shuffle:s.shuffle,size:s.size,some:s.some,sortBy:s.sortBy},n._function={after:s.after,ary:s.ary,before:s.before,bind:s.bind,bindKey:s.bindKey,curry:s.curry,curryRight:s.curryRight,debounce:s.debounce,defer:s.defer,delay:s.delay,flip:s.flip,memoize:s.memoize,negate:s.negate,once:s.once,overArgs:s.overArgs,partial:s.partial,partialRight:s.partialRight,rearg:s.rearg,rest:s.rest,spread:s.spread,throttle:s.throttle,unary:s.unary,wrap:s.wrap},n._string={camelCase:s.camelCase,capitalize:s.capitalize,deburr:s.deburr,endsWith:s.endsWith,escape:s.escape,escapeRegExp:s.escapeRegExp,kebabCase:s.kebabCase,lowerCase:s.lowerCase,lowerFirst:s.lowerFirst,pad:s.pad,padEnd:s.padEnd,padStart:s.padStart,parseInt:s.parseInt,repeat:s.repeat,replace:s.replace,snakeCase:s.snakeCase,split:s.split,startCase:s.startCase,startsWith:s.startsWith,template:s.template,toLower:s.toLower,toUpper:s.toUpper,trim:s.trim,trimEnd:s.trimEnd,trimStart:s.trimStart,truncate:s.truncate,unescape:s.unescape,upperCase:s.upperCase,upperFirst:s.upperFirst,words:s.words},n._object={assign:s.assign,assignIn:s.assignIn,assignInWith:s.assignInWith,assignWith:s.assignWith,at:s.at,create:s.create,defaults:s.defaults,defaultsDeep:s.defaultsDeep,entries:s.entries,entriesIn:s.entriesIn,extend:s.extend,findKey:s.findKey,findLastKey:s.findLastKey,forIn:s.forIn,forInRight:s.forInRight,forOwn:s.forOwn,forOwnRight:s.forOwnRight,functions:s.functions,functionsIn:s.functionsIn,get:s.get,has:s.has,hasIn:s.hasIn,invert:s.invert,invertBy:s.invertBy,invoke:s.invoke,keys:s.keys,keysIn:s.keysIn,mapKeys:s.mapKeys,mapValues:s.mapValues,merge:s.merge,mergeWith:s.mergeWith,omit:s.omit,omitBy:s.omitBy,pick:s.pick,pickBy:s.pickBy,result:s.result,set:s.set,setWith:s.setWith,toPairs:s.toPairs,toPairsIn:s.toPairsIn,transform:s.transform,unset:s.unset,update:s.update,updateWith:s.updateWith,values:s.values,valuesIn:s.valuesIn},t.Utils=n},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e[e.Transient=-1]="Transient",e[e.Persistent=0]="Persistent",e[e.New=1]="New",e[e.Modified=2]="Modified",e[e.Deleted=3]="Deleted"}(t.EntityState||(t.EntityState={})),t.ENTITY_VERSION_PROPERTY="_version_",t.ENTITY_EXTENSION_SYMBOL="__extension__",function(e){e[e.New=1]="New",e[e.Modify=2]="Modify",e[e.Delete=3]="Delete"}(t.EntityChangeType||(t.EntityChangeType={}))},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(0),r=i(1),n=i(3),a=i(4);var o;!function(e){e.String="String",e.Number="Number",e.BigInt="BigInt",e.Text="Text",e.JSON="Json"}(o=t.FieldTypes||(t.FieldTypes={}));t.InvalidEntityKeyError=class extends Error{constructor(e,t){super(`Invalid entity keyï¼Œ( model = ${e}, key = '${JSON.stringify(t)}' ) `)}};class l{constructor(e,t){this.schema=n.Utils.Lang.cloneDeep(e),this.name=t,this.memory=!0===e.memory,this.readonly=!0===e.readonly,this.local=!0===e.local,this.maxCachedCount=this.memory?Number.POSITIVE_INFINITY:e.maxCached,this.propertiesSet=new Set,this.uniquePropertiesSet=new Set,this.attachVersionField(),this.parseProperties()}attachVersionField(){this.schema.tableFields.some(e=>e.name===a.ENTITY_VERSION_PROPERTY)||this.schema.tableFields.push({name:"_version_",type:o.Number,default:0})}convertType(e){return e}getIndexes(e,t){let i=new Map;return e.filter(e=>void 0!==e[t]).forEach(e=>{let r=e[t];if(!s.isBoolean(r)&&!s.isString(r))throw new Error("index or unique should be true or a valid name");const n=e.name;if(!0===r)i.set(e.name,[n]);else if(s.isString(r)){const e=r;i.has(e)||i.set(e,new Array),i.get(e).push(n)}}),[...i.keys()].map(e=>({name:e,properties:i.get(e)}))}parseNormalIndexes(e){return this.getIndexes(e.tableFields,"index")}parseUniqueIndexes(e){return this.getIndexes(e.tableFields,"unique")}parseProperties(){const e=this.schema.tableFields.filter(e=>!0===e.primary_key).map(e=>e.name);if(this.compositKeyProperties=this.schema.tableFields.filter(e=>!0===e.composite_key).map(e=>e.name),this.primaryKeyProperty=1===e.length?e[0]:void 0,!(void 0!==this.primaryKeyProperty!=this.compositKeyProperties.length>1))throw new Error("model must have primary key or composite keys, but can not both");this.allPropertyTypes=new Map,this.schema.tableFields.forEach(e=>this.allPropertyTypes.set(e.name,this.convertType(e.type))),this.allProperties=this.schema.tableFields.map(e=>e.name),this.allJsonProperties=this.schema.tableFields.filter(e=>e.type===o.JSON).map(e=>e.name),this.allNormalIndexes=this.parseNormalIndexes(this.schema),this.allUniqueIndexes=this.parseUniqueIndexes(this.schema),this.allProperties.forEach(e=>this.propertiesSet.add(e)),this.allUniqueIndexes.forEach(e=>e.properties.forEach(e=>this.uniquePropertiesSet.add(e)))}get properties(){return this.allProperties}get jsonProperties(){return this.allJsonProperties}get schemaObject(){return this.schema}get isCompsiteKey(){return this.compositeKeys.length>1}get primaryKey(){return this.primaryKeyProperty}get compositeKeys(){return this.compositKeyProperties}get indexes(){return this.allNormalIndexes}get uniqueIndexes(){return this.allUniqueIndexes}get maxCached(){return this.maxCachedCount}get modelName(){return this.name}get isLocal(){return this.local}get isReadonly(){return this.readonly}get memCached(){return this.memory}hasUniqueProperty(...e){return e.some(e=>this.uniquePropertiesSet.has(e))}isValidProperty(e){return this.propertiesSet.has(e)}isValidEntityKey(e){return this.isValidPrimaryKey(e)||this.isValidUniqueKey(e)}isNormalizedPrimaryKey(e){if(!s.isObject(e))return;const t=e,i=Object.keys(t);return this.isCompsiteKey?this.isValidPrimaryKey(t):1===i.length&&i[0]===this.primaryKey}setPrimaryKey(e,t){if(!this.isValidPrimaryKey(t))throw new Error(`Invalid PrimaryKey of model '${this.modelName}', key=''${JSON.stringify(t)}`);return!this.isCompsiteKey&&r.isPrimitiveKey(t)?e[this.primaryKey]=t:this.isCompsiteKey?r.partialCopy(t,this.compositeKeys,e):r.partialCopy(t,[this.primaryKey],e),e}getPrimaryKey(e){return this.isCompsiteKey?r.partialCopy(e,this.compositeKeys):e[this.primaryKey]}getNormalizedPrimaryKey(e){return this.isCompsiteKey?r.partialCopy(e,this.compositeKeys):r.partialCopy(e,[this.primaryKey])}normalizePrimaryKey(e){if(!r.isPrimitiveKey(e))return e;let t={};return t[this.primaryKey]=e,t}isValidPrimaryKey(e){return!this.isCompsiteKey&&(r.isPrimitiveKey(e)||this.isNormalizedPrimaryKey(e))||0===n.Utils.Array.xor(Object.keys(e),this.compositeKeys).length}isValidUniqueKey(e){return void 0!==this.getUniqueName(e)}getUniqueName(e){if(this.isValidPrimaryKey(e))return l.PRIMARY_KEY_NAME;let t=Object.keys(e);if(1===t.length&&t[0]===this.primaryKey)return l.PRIMARY_KEY_NAME;const i=this.uniqueIndexes.find(e=>0===n.Utils.Array.xor(e.properties,t).length);return void 0===i?void 0:i.name}isPrimaryKeyUniqueName(e){return e===l.PRIMARY_KEY_NAME}getUniqueIndex(e){return this.allUniqueIndexes.find(t=>t.name===e)}resolveKey(e){const t=this.getUniqueName(e);if(void 0!==t)return this.isPrimaryKeyUniqueName(t)?{isPrimaryKey:!0,uniqueName:t,key:this.setPrimaryKey({},e)}:{isUniqueKey:!0,uniqueName:t,key:e}}copyProperties(e,t=!0){return e?r.partialCopy(e,t?this.allProperties:e=>this.allProperties.includes(e)):e}setDefaultValues(e){this.schema.tableFields.forEach(t=>{void 0!==t.default&&(null===e[t.name]||void 0===e[t.name])&&(e[t.name]=t.default)})}splitEntityAndVersion(e){const t=e[a.ENTITY_VERSION_PROPERTY];return Reflect.deleteProperty(e,a.ENTITY_VERSION_PROPERTY),{version:t,entity:e}}}l.PRIMARY_KEY_NAME="__PrimaryKey__",t.ModelSchema=l},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(12),r=i(7);class n{constructor(e){this.connection=e}async commit(){await this.connection.execute("COMMIT;")}async rollback(){await this.connection.execute("ROLLBACK;")}}t.SqliteConnection=class{constructor(e){this.options=e,this.sqlite=new s.SqliteWrapper}get connectionOptions(){return this.options}get isConnected(){return this.sqlite.isConnected}async connect(){return this.sqlite.asynOpen(this.options.storage)}async disconnect(){return await this.sqlite.asynClose()}async query(e,t){return await this.sqlite.asynQuery(e,t)}querySync(e,t){return this.sqlite.query(e,t)}ensureExecuteEffected(e){if(0===e.rowsEffected)throw new Error("None row effected")}executeBatchSync(e){return this.sqlite.executeBatch(e||[],this.ensureExecuteEffected)}async executeBatch(e){return await this.sqlite.asyncExecuteBatch(e||[],this.ensureExecuteEffected)}executeSync(e,t,i=!1){const s=this.sqlite.execute(e,t);return i&&this.ensureExecuteEffected(s),s}async execute(e,t,i=!1){const s=await this.sqlite.asynExecute(e,t);return i&&this.ensureExecuteEffected(s),s}async runScript(e){e.split(r.MULTI_SQL_SEPARATOR).forEach(async e=>await(""!==e.trim())&&this.sqlite.execute(e,[]))}async beginTrans(){return await this.execute("BEGIN TRANSACTION;"),new n(this)}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(5),r=i(1),n=i(0),a=i(3),o=i(16)({separatedValues:!1});var l;t.MULTI_SQL_SEPARATOR=";",function(e){e[e.Schema=0]="Schema",e[e.Select=1]="Select",e[e.Insert=2]="Insert",e[e.Update=3]="Update",e[e.Delete=4]="Delete",e[e.Other=9]="Other"}(l=t.SqlType||(t.SqlType={}));t.JsonSqlBuilder=class{getTableName(e){return a.Utils.String.snakeCase(e)+"s"}getPrimaryKeyCondition(e,t){return e.setPrimaryKey({},t)}buildDropSchema(e){return`drop table "${this.getTableName(e.modelName)}"`}buildSchema(e){let t=new Array;const i=Object.assign({type:"create"},r.deepCopy(e.schemaObject));e.jsonProperties.forEach(e=>i.tableFields.find(t=>t.name===e).type=s.FieldTypes.Text),i.tableFields.filter(e=>n.isString(e.unique)).forEach(e=>Reflect.deleteProperty(e,"unique"));let a=o.build(i);t.push(a.query);const l=this.getTableName(e.modelName);e.indexes.forEach(e=>{t.push(o.build({type:"index",table:l,name:l+"_"+e.name,indexOn:e.properties.join(",")}).query)});const c=i.tableFields.filter(e=>!0===e.unique).map(e=>e.name),h=e.uniqueIndexes.filter(e=>!(1===e.properties.length&&c.some(t=>t===e.properties[0])));return e.isCompsiteKey&&h.push({name:"composite_primary_key",properties:e.compositeKeys}),h.forEach(e=>{t.push(o.build({type:"unique",table:l,name:l+"_"+e.name,uniqueOn:e.properties.join(",")}).query)}),t}buildInsert(e,t){let i={type:l.Insert};return Object.assign(i,o.build({type:"insert",table:this.getTableName(e.modelName),values:this.replaceJsonFields(e,t)}))}buildDelete(e,t){let i={type:l.Delete};return Object.assign(i,o.build({type:"remove",table:this.getTableName(e.modelName),condition:this.getPrimaryKeyCondition(e,t)}))}buildUpdate(e,t,i,s){const r=this.getTableName(e.modelName);let n=this.getPrimaryKeyCondition(e,t);n._version_=s;let a={type:l.Update};return Object.assign(a,o.build({type:"update",table:r,modifier:this.replaceJsonFields(e,i),condition:n}))}buildSelect(e,t,i,s,r,a){const c=this.getTableName(e.modelName);let h;if(n.isArray(t)){let o=t||e.properties.map(t=>e.schemaObject.table+"."+t),l=n.isNumber(s)?{limit:s}:s||{},u=r||{};for(let e of Reflect.ownKeys(u)){let t=u[e]||-1;u[e]="ASC"===t?1:"DESC"===t?-1:t}h={type:"select",table:c,fields:o,condition:i,limit:l.limit,offset:l.offset,sort:u,join:a}}else{let e=t;h=Object.assign({type:"select",table:c},e)}let u={type:l.Select};return Object.assign(u,o.build(h))}replaceJsonFields(e,t){if(0===e.jsonProperties.length)return t;let i=Object.assign({},t);return e.jsonProperties.forEach(e=>{Reflect.has(t,e)&&(i[e]=JSON.stringify(t[e]))}),i}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(2),r=i(0),n=i(20),a=i(5),o=i(7),l=i(1),c=i(15),h=i(14),u=i(3);class d{constructor(e,t,i){const r=Object.assign({},i),a=r.name;this.log=s.LogManager.getLogger(d.name+(void 0===a?"":`_${a}`)),this.sessionSerial=-1,this.connection=e,this.unconfirmedLocks=new Set,this.confirmedLocks=new Set,this.schemas=new Map,this.sessionCache=new n.LRUEntityCache(this.schemas),this.sqlBuilder=new o.JsonSqlBuilder;const l=r.maxHistoryVersionsHold||d.DEFAULT_HISTORY_VERSION_HOLD;this.entityTracker=new h.SnapshotEntityTracker(this.sessionCache,this.schemas,l,t),this.trackerSqlBuilder=new c.BasicTrackerSqlBuilder(this.entityTracker,this.schemas,this.sqlBuilder)}makeByKeyCondition(e,t){return e.resolveKey(t).key}trackPersistentEntities(e,t,i=!1){let s=new Array;return t.forEach(t=>{let r=e.getPrimaryKey(t),n=this.entityTracker.getTrackingEntity(e,r),a=i&&void 0!==n?n:this.entityTracker.trackPersistent(e,t);s.push(e.copyProperties(a,!0))}),s}reset(e=!1){e&&this.sessionCache.clear()}undefinedIfDeleted(e){return l.deepCopy(e)}async queryEntities(e,t){const i=await this.connection.query(t.query,t.parameters);return this.replaceEntitiesJsonPropertis(e,i)}queryEntitiesSync(e,t){const i=this.connection.querySync(t.query,t.parameters);return this.replaceEntitiesJsonPropertis(e,i)}get isOpen(){return this.connection&&this.connection.isConnected}syncSchema(e){this.sqlBuilder.buildSchema(e).forEach(e=>{this.connection.executeSync(e)})}async updateSchema(e){if(await this.exists(e,{}))throw new Error(`Can not update schema(${e.modelName}) because table is not empty`);const t=this.sqlBuilder.buildDropSchema(e);await this.connection.execute(t),this.syncSchema(e),this.registerSchema(e)}registerSchema(...e){e.forEach(e=>{this.schemas.set(e.modelName,e)})}async initSerial(e){this.sessionSerial=e;const t=this.entityTracker;e>=0&&await t.initVersion(e)}async close(){this.reset(!0),await this.connection.disconnect()}getAll(e,t){if(!e.memCached)throw new Error("getAll only support in memory model");const i=e=>void 0!==this.undefinedIfDeleted(e),s=t?e=>t(e)&&i(e):i;return this.sessionCache.getAll(e.modelName,s)}loadAll(e){if(e.memCached&&this.sessionCache.existsModel(e.modelName)){let t=this.sessionCache.getAll(e.modelName)||[];return this.trackPersistentEntities(e,t,!0)}return[]}async getMany(e,t,i=!0){const s=this.sqlBuilder.buildSelect(e,e.properties,t);let r=await this.queryEntities(e,s);return i?this.trackPersistentEntities(e,r,!0):r}async query(e,t,i,s,r,n){const a=this.sqlBuilder.buildSelect(e,r||e.properties,t,i,s,n);return await this.queryEntities(e,a)}async queryByJson(e,t){const i=this.sqlBuilder.buildSelect(e,t);return await this.queryEntities(e,i)}async exists(e,t){let{query:i,parameters:s}=this.sqlBuilder.buildSelect(e,[],t);i=`select exists(${i.replace(o.MULTI_SQL_SEPARATOR,"")}) as exist`;const n=await this.connection.query(i,s);return r.isArray(n)&&parseInt(n[0].exist)>0}async count(e,t){let i=await this.queryByJson(e,{fields:"count(*) as count",condition:t});return r.isArray(i)?parseInt(i[0].count):0}create(e,t){const i=e.getNormalizedPrimaryKey(t);if(void 0===i)throw new Error(`entity must contains primary key ( model = '${e.modelName}' entity = '${t}' )`);if(this.sessionCache.exists(e.modelName,i))throw new Error(`entity exists already ( model = '${e.modelName}' key = '${JSON.stringify(i)}' )`);return l.deepCopy(this.entityTracker.trackNew(e,t))}loadEntityByKeySync(e,t){const i=this.makeByKeyCondition(e,t),s=this.sqlBuilder.buildSelect(e,e.properties,i),r=this.queryEntitiesSync(e,s);if(r.length>1)throw new Error(`entity key is duplicated ( model = '${e.modelName}' key = '${JSON.stringify(t)}' )`);return 1===r.length?r[0]:void 0}async loadEntityByKey(e,t){const i=this.makeByKeyCondition(e,t),s=this.sqlBuilder.buildSelect(e,e.properties,i),r=await this.queryEntities(e,s);if(r.length>1)throw new Error(`entity key is duplicated ( model = '${e.modelName}' key = '${JSON.stringify(t)}' )`);return 1===r.length?r[0]:void 0}replaceJsonProperties(e,t){if(0===e.jsonProperties.length)return t;let i=Object.assign({},t);return e.jsonProperties.forEach(e=>{Reflect.has(i,e)&&(i[e]=JSON.parse(String(t[e])))}),i}replaceEntitiesJsonPropertis(e,t){return 0===e.jsonProperties.length?t:t.map(t=>this.replaceJsonProperties(e,t))}async load(e,t){const i=this.getCachedEntity(e,t);if(void 0!==i)return i;const s=await this.loadEntityByKey(e,t);if(void 0===s)return;const r=this.entityTracker.trackPersistent(e,s);return e.copyProperties(r,!0)}loadSync(e,t){const i=this.getCachedEntity(e,t);if(void 0!==i)return i;const s=this.loadEntityByKeySync(e,t);if(void 0===s)return;const r=this.entityTracker.trackPersistent(e,s);return e.copyProperties(r,!0)}getChanges(){return this.entityTracker.getConfimedChanges()}normalizeEntityKey(e,t){const i=e.resolveKey(t);if(void 0===i)throw new a.InvalidEntityKeyError(e.modelName,t);return i}getCached(e,t){const i=this.normalizeEntityKey(e,t),s=this.entityTracker.getTrackingEntity(e,i.key);return s||(i.isPrimaryKey?this.sessionCache.get(e.modelName,i.key):this.sessionCache.getUnique(e.modelName,i.uniqueName,i.key))}getTrackingOrCachedEntity(e,t){const i=this.getCached(e,t);return void 0===i?void 0:this.undefinedIfDeleted(i)}getCachedEntity(e,t){const i=this.getCached(e,t);return void 0===i?void 0:this.undefinedIfDeleted(i)}clearLocks(){this.unconfirmedLocks.clear(),this.confirmedLocks.clear()}confirmLocks(){this.unconfirmedLocks.forEach(e=>this.confirmedLocks.add(e))}lockInThisSession(e,t=!1){if(!(this.confirmedLocks.has(e)||this.unconfirmedLocks.has(e))){return(this.entityTracker.isConfirming?this.unconfirmedLocks:this.confirmedLocks).add(e),this.log.traceEnabled&&this.log.trace(`SUCCESS lock name = '${e}'`),!0}if(this.log.warnEnabled&&this.log.warn(`FAILD lock ${e}`),!t)throw new Error(`Lock name = ${e} exists already`);return!1}async saveChanges(e){const t=e||++this.sessionSerial;this.log.traceEnabled&&this.log.trace(`BEGIN saveChanges ( serial = ${t} )`),this.commitEntityTransaction(),u.Utils.Performace.time("Build sqls");const i=this.trackerSqlBuilder.buildChangeSqls();u.Utils.Performace.restartTime(`Execute sqls (${i.length})`);const s=await this.connection.beginTrans();try{return await this.connection.executeBatch(i),await s.commit(),u.Utils.Performace.restartTime("Accept changes"),this.entityTracker.acceptChanges(t),u.Utils.Performace.endTime(),this.clearLocks(),this.sessionSerial=t,this.log.traceEnabled&&this.log.trace(`SUCCESS saveChanges ( serial = ${t} )`),t}catch(e){throw this.log.errorEnaled&&this.log.error(`FAILD saveChanges ( serial = ${t} )`,e),await s.rollback(),this.entityTracker.rejectChanges(),e}}async rollbackChanges(e){if(this.sessionSerial<e)return this.sessionSerial;const t=this.sessionSerial;this.log.traceEnabled&&this.log.trace(`BEGIN rollbackChanges ( serial = ${e} )`);const i=await this.trackerSqlBuilder.buildRollbackChangeSqls(e+1),s=await this.connection.beginTrans();try{return await this.connection.executeBatch(i),await s.commit(),this.entityTracker.rejectChanges(),await this.entityTracker.rollbackChanges(e+1),this.clearLocks(),this.sessionSerial=e,this.log.traceEnabled&&this.log.trace(`SUCCESS rollbackChanges (serial : ${t} -> ${this.sessionSerial})`),this.sessionSerial}catch(e){throw this.log.errorEnaled&&this.log.error(`FAILD rollbackChanges (serial : ${t} -> ${this.sessionSerial})`,e),await s.rollback(),e}}ensureEntityTracking(e,t){let i=this.getCached(e,t);if(void 0===i){const s=this.loadEntityByKeySync(e,t);if(void 0===s)throw Error(`Entity not found ( model = '${e.modelName}', key = '${JSON.stringify(t)}' )`);i=this.entityTracker.trackPersistent(e,s)}return i}update(e,t,i){const s=this.ensureEntityTracking(e,t);this.entityTracker.trackModify(e,s,i)}increase(e,t,i){const s=this.ensureEntityTracking(e,t);let r={};return Object.keys(i).forEach(e=>{r[e]=void 0===s[e]?i[e]:i[e]+s[e]}),this.entityTracker.trackModify(e,s,r),r}delete(e,t){const i=this.ensureEntityTracking(e,t);this.entityTracker.trackDelete(e,i)}async beginTransaction(){return await this.connection.beginTrans()}beginEntityTransaction(){this.entityTracker.beginConfirm()}static setToString(e){return JSON.stringify(new Array(...e.keys()))}commitEntityTransaction(){this.entityTracker.confirm(),this.log.traceEnabled&&this.log.trace(`commit locks ${d.setToString(this.unconfirmedLocks)}`),this.unconfirmedLocks.forEach(e=>this.confirmedLocks.add(e))}rollbackEntityTransaction(){this.entityTracker.cancelConfirm(),this.log.traceEnabled&&this.log.trace(`rollback locks ${d.setToString(this.unconfirmedLocks)}`),this.unconfirmedLocks.clear()}}d.DEFAULT_HISTORY_VERSION_HOLD=10,t.DbSession=d},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(24),r="__last_block_height__";t.LevelBlock=class{constructor(e,t={}){const i=new s.SubLevelMeta("blk","height",[{fieldName:"id"},{fieldName:"delegate"}]),r=new s.SubLevelMeta("his","height",[]);this.db=new s.LevelDB(e,[i,r],t),this.lastHeight=-1}async getLastBlockHeightFromDb(){let e=await this.blockDb.get(r,{});return void 0===e&&(e=this.getLastHeightJson(-1),await this.blockDb.put(r,e)),e.height}async open(){await this.db.open(),this.blockDb=this.db.getSubLevel("blk"),this.historyDb=this.db.getSubLevel("his"),this.lastHeight=await this.getLastBlockHeightFromDb()}async close(){await this.db.close()}get lastBlockHeight(){return this.lastHeight}isKeyNotFoundError(e){return"NotFoundError"===e.name}getLastHeightJson(e){return{height:e,id:"NULL",delegate:"NULL"}}async appendBlock(e,t){if(!e||!e.id||!e.delegate||void 0===e.height)throw new Error("Invalid block data");await this.historyDb.put(e.height,t),await this.blockDb.batch([{type:"put",key:e.height,value:e},{type:"put",key:r,value:this.getLastHeightJson(e.height)}]),this.lastHeight=e.height}async getBlock(e){try{return await this.blockDb.get(e)}catch(e){if(!this.isKeyNotFoundError(e))throw e}}async getHistoryChanges(e,t){let i=new Map;for(let s=e;s<=t;s++){const e=await this.historyDb.get(s);e&&i.set(s,e)}return i}async deleteLastBlock(e){if(e!==this.lastBlockHeight)throw new Error(`invalid last block height '${e}'`);await this.blockDb.batch([{type:"del",key:e},{type:"put",key:r,value:this.getLastHeightJson(e-1)}]),await this.historyDb.del(e),this.lastHeight--}async getBlockById(e){return await this.blockDb.getBy("id",e)}async getBlocksByHeightRange(e,t){let i=new Array;for(let s=e;s<=t;s++){let e=await this.getBlock(s);e&&i.push(e)}return i}async getBlocksByIds(e){let t=new Array;for(let i=0;i<e.length;i++){let s=await this.getBlockById(e[i]);s&&t.push(s)}return t}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.BlockCache=class{constructor(e){this.cache=new Map,this.minHeight=-1,this.maxHeight=-1,this.maxCachedCount=e}isCached(e){return e>0&&e>=this.minHeight&&e<=this.maxHeight}get cachedHeightRange(){return{min:this.minHeight,max:this.maxHeight}}push(e){if(this.maxHeight>=0&&e.height!==this.maxHeight+1)throw new Error(`invalid block height, expected : ${this.maxHeight+1} actual : ${e.height}`);this.cache.set(e.height,e),this.maxHeight=e.height,this.minHeight=-1===this.minHeight?e.height:this.minHeight,this.cache.size>=this.maxCachedCount&&this.cache.delete(this.minHeight++)}get(e){return this.cache.get(e)}getById(e){for(const t of this.cache.values())if(t.id===e)return t}evitUntil(e){if(e>this.maxHeight)return;const t=Math.max(e,this.minHeight);for(let e=t+1;e<=this.maxHeight;e++)this.cache.delete(e);this.minHeight=t===this.minHeight?-1:this.minHeight,this.maxHeight=-1===this.minHeight?-1:t}}},function(e,t){e.exports=require("better-sqlite3")},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(0),r=i(2),n=i(11);t.SqliteWrapper=class{constructor(){this.log=r.LogManager.getLogger("SqliteWrapper")}open(e,t){let i={err:null,result:!0};try{this.db=new n(e),this.log.traceEnabled&&this.log.trace(`SUCCESS open ( db = ${e} )`)}catch(s){if(i={err:s,result:!1},this.log.errorEnaled&&this.log.error(`FAILD open ( db = ${e} )`,s),!t)throw s}return t&&t(i.err,i.result),i.result}get isConnected(){return this.db.open}async asynOpen(e){return s.promisify(this.open).call(this,e)}close(e){let t={err:null,result:!0};try{this.db&&this.isConnected?(this.db.close(),this.log.traceEnabled&&this.log.trace("SUCCESS close")):this.log.infoEnabled&&this.log.info("closed already")}catch(i){if(t={err:i,result:!1},this.log.errorEnaled&&this.log.error("FAILD close",i),!e)throw i}return e&&e(t.err,t.result),t.result}asynClose(){return s.promisify(this.close).call(this)}execute(e,t,i){let s={err:null,result:{lastInsertRowId:"0",rowsEffected:0}};try{const r=this.db.prepare(e).run(t||[]);s.result={lastInsertRowId:r.lastInsertROWID.toString(),rowsEffected:r.changes},this.log.traceEnabled&&this.log.trace(`SUCCESS execute sql = ${e} param = ${JSON.stringify(t)}, effected = ${s.result.rowsEffected}`)}catch(r){if(s.err=r,this.log.errorEnaled&&this.log.error(`FAILD execute sql = ${e} param = ${JSON.stringify(t)}`,r),!i)throw r}return i&&i(s.err,s.result),s.result}query(e,t,i){let s={err:null,result:new Array};try{s.result=this.db.prepare(e).all(t||[]),this.log.traceEnabled&&this.log.trace(`SUCCESS query sql = ${e} param = ${JSON.stringify(t)}, result count = ${s.result.length}`)}catch(r){if(s.err=r,this.log.errorEnaled&&this.log.error(`FAILD query sql = ${e} param = ${JSON.stringify(t)}`,r),!i)throw r}return i&&i(s.err,s.result),s.result}executeBatch(e,t,i){let s,r={err:null,result:new Array};try{e.forEach(e=>{s=e;let i=this.execute(e.query,e.parameters);t&&t(i,e),r.result.push(i)})}catch(e){if(r.err=e,this.log.errorEnaled&&this.log.error(`FAILD executeBatch, sql = ${s.query} param = ${JSON.stringify(s.parameters)}`,e),!i)throw e}return i&&i(r.err,r.result),r.result}async asynExecute(e,t){return s.promisify(this.execute).call(this,e,t)}async asynQuery(e,t){return s.promisify(this.query).call(this,e,t)}asyncExecuteBatch(e,t){return s.promisify(this.executeBatch).call(this,e,t)}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(3),r=i(1),n=i(4),a=i(0);t.Stack=Array;t.BasicEntityTracker=class{constructor(e,i,s,r,n){this.log=r,this.cache=e,this.confirming=!1,this.schemas=i,this.doLoadHistory=n,this.history=new Map,this.allTrackingEntities=new Map,this.unconfirmedChanges=new t.Stack,this.confirmedChanges=new t.Stack,this.minVersion=-1,this.currentVersion=-1,this.maxHistoryVersionsHold=s}async loadHistory(e,t){return a.isFunction(this.doLoadHistory)?await this.doLoadHistory(e,t):new Map}async initVersion(e){if(-1===this.currentVersion){const t=await this.loadHistory(e,e);this.attachHistory(t)}}makeModelAndKey(e,t){let i={m:e.modelName,k:t};return JSON.stringify(i)}splitModelAndKey(e){let t=JSON.parse(e);return{model:t.m,key:t.k}}get trackingEntities(){return this.allTrackingEntities.values()}isTracking(e,t){const i=this.makeModelAndKey(e,t);return this.allTrackingEntities.has(i)}getConfimedChanges(){return this.confirmedChanges}get changesStack(){return this.isConfirming?this.unconfirmedChanges:this.confirmedChanges}buildTrackingEntity(e,t,i){return t}ensureNotracking(e,t){if(void 0!==this.getTrackingEntity(e,t))throw Error(`Entity (model='${e.modelName}', key='${JSON.stringify(t)}') is tracking already`)}getTracking(e,t){const i=this.getTrackingEntity(e,t);if(void 0===i)throw Error(`Entity (model='${e.modelName}', key='${JSON.stringify(t)}') is not tracking`);return i}trackNew(e,t){const i=e.getNormalizedPrimaryKey(t);this.ensureNotracking(e,i);let r=s.Utils.Lang.cloneDeep(t);e.setDefaultValues(r),r[n.ENTITY_VERSION_PROPERTY]=1;let a=this.buildTrackingEntity(e,r,n.EntityState.New);return this.cache.put(e.modelName,i,a),this.changesStack.push(this.buildCreateChanges(e,r)),a}trackPersistent(e,t){const i=e.getNormalizedPrimaryKey(t);this.ensureNotracking(e,i);const r=s.Utils.Lang.cloneDeep(t);let a=this.buildTrackingEntity(e,r,n.EntityState.Persistent);return this.cache.put(e.modelName,i,a),a}trackDelete(e,t){this.changesStack.push(this.buildDeleteChanges(e,t,t._version_)),this.cache.evit(e.modelName,e.getNormalizedPrimaryKey(t))}trackModify(e,t,i){const r=Object.keys(i).filter(r=>e.isValidProperty(r)&&r!==n.ENTITY_VERSION_PROPERTY&&!s.Utils.Lang.isEqual(t[r],i[r])).map(e=>({name:e,value:i[e]}));0!==r.length&&(this.changesStack.push(this.buildModifyChanges(e,t,r,++t._version_)),this.cache.refreshCached(e.modelName,e.getNormalizedPrimaryKey(t),r))}getTrackingEntity(e,t){const i=e.resolveKey(t);if(void 0!==i)return i.isPrimaryKey?this.cache.get(e.modelName,i.key):this.cache.getUnique(e.modelName,i.uniqueName,i.key)}acceptChanges(e){this.log.traceEnabled&&this.log.trace(`BEGIN acceptChanges Version = ${e}`),this.history.set(e,this.confirmedChanges),this.confirmedChanges=new t.Stack,this.removeExpiredHistory(),this.allTrackingEntities.clear(),this.minVersion=-1===this.minVersion?e:this.minVersion,this.currentVersion=e,this.log.traceEnabled&&this.log.trace(`SUCCESS acceptChanges Version = ${e}`)}buildCreateChanges(e,t){let i=new Array;for(const s in t)e.isValidProperty(s)&&i.push({name:s,current:t[s]});return{type:n.EntityChangeType.New,model:e.modelName,primaryKey:e.getNormalizedPrimaryKey(t),dbVersion:1,propertyChanges:i}}buildModifyChanges(e,t,i,s){let r=new Array;return i.forEach(e=>r.push({name:e.name,current:e.value,original:t[e.name]})),r.push({name:n.ENTITY_VERSION_PROPERTY,current:s,original:s-1}),{type:n.EntityChangeType.Modify,model:e.modelName,primaryKey:e.getNormalizedPrimaryKey(t),dbVersion:s,propertyChanges:r}}buildDeleteChanges(e,t,i){let s=new Array;for(const i in t)e.isValidProperty(i)&&s.push({name:i,original:t[i]});return{type:n.EntityChangeType.Delete,model:e.modelName,primaryKey:e.getNormalizedPrimaryKey(t),dbVersion:i,propertyChanges:s}}undoEntityChanges(e){switch(e.type){case n.EntityChangeType.New:this.cache.get(e.model,e.primaryKey)&&this.cache.evit(e.model,e.primaryKey);break;case n.EntityChangeType.Modify:const t=e.propertyChanges.map(e=>({name:e.name,value:e.original}));this.cache.refreshCached(e.model,e.primaryKey,t);break;case n.EntityChangeType.Delete:let i=r.makeJsonObject(e.propertyChanges,e=>e.name,e=>e.original);const s=this.schemas.get(e.model),a=this.buildTrackingEntity(s,i,n.EntityState.Persistent);this.trackPersistent(s,a)}}undoChanges(e){let t;for(;void 0!==(t=e.pop());)this.undoEntityChanges(t)}rejectChanges(){this.cancelConfirm(),this.undoChanges(this.confirmedChanges)}async rollbackChanges(e){if(e>this.currentVersion)return;const t=this.currentVersion;for(this.log.traceEnabled&&this.log.trace(`BEGIN rollbackChanges Version : ${t}`),await this.loadHistoryUntil(e);this.currentVersion>=e;){const e=this.getHistoryByVersion(this.currentVersion);this.undoChanges(e),this.currentVersion--}this.minVersion=Math.min(this.minVersion,this.currentVersion),this.log.traceEnabled&&this.log.trace(`SUCCESS rollbackChanges Version : ${t} -> ${this.currentVersion}`)}get isConfirming(){return this.confirming}beginConfirm(){this.confirming=!0,this.unconfirmedChanges.length>0&&this.log.warnEnabled&&this.log.warn(`unconfimred changes(${this.unconfirmedChanges.length}) detected , you should call commit or cancel changes`),this.unconfirmedChanges=new t.Stack,this.log.traceEnabled&&this.log.trace("BEGIN beginConfirm")}confirm(){this.confirmedChanges.push(...this.unconfirmedChanges),this.unconfirmedChanges=new t.Stack,this.confirming=!1,this.log.traceEnabled&&this.log.trace("SUCCESS confirm ")}cancelConfirm(){this.undoChanges(this.unconfirmedChanges),this.confirming=!1,this.log.traceEnabled&&this.log.trace("SUCCESS cancelConfirm ")}attachHistory(e){this.log.infoEnabled&&this.log.info(`BEGIN attachHistory history version = ${JSON.stringify(this.historyVersion)}`),e.forEach((e,t)=>{this.history.set(t,e),this.minVersion=this.minVersion<0?t:Math.min(t,this.minVersion),this.currentVersion=Math.max(t,this.currentVersion)}),this.log.infoEnabled&&this.log.info(`SUCCESS attachHistory size = ${JSON.stringify(e?e.size:0)}`)}get historyVersion(){return{min:this.minVersion,max:this.currentVersion}}getHistoryByVersion(e,i=!1){return!this.history.has(e)&&i&&this.history.set(e,new t.Stack),this.history.get(e)}async loadHistoryUntil(e){if(e<this.minVersion){const t=await this.loadHistory(e,this.minVersion);this.attachHistory(t)}}removeExpiredHistory(){this.currentVersion-this.minVersion>this.maxHistoryVersionsHold&&this.clearHistoryBefore(this.currentVersion-this.maxHistoryVersionsHold)}async getChangesUntil(e){await this.loadHistoryUntil(e);const i=new t.Stack;let s=e;for(;s<=this.currentVersion;){let e=this.getHistoryByVersion(s++);e&&i.push(...e)}return i}clearHistoryBefore(e){if(!(this.minVersion>=e||this.currentVersion<e)){for(let t=this.minVersion;t<e;t++)this.history.delete(t);this.minVersion=e}}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(13),r=i(2);t.SnapshotEntityTracker=class extends s.BasicEntityTracker{constructor(e,t,i,s){super(e,t,i,r.LogManager.getLogger("SnapshotEntityTracker"),s)}}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(1),r=i(4);class n{constructor(e,t,i){this.tracker=e,this.schemas=t,this.sqlBuilder=i}get entityTracker(){return this.tracker}buildChangeSqls(){return this.tracker.getConfimedChanges().map(e=>this.buildSqlAndParameters(this.schemas.get(e.model),e.primaryKey,e))}async buildRollbackChangeSqls(e){let t=new Array;const i=await this.tracker.getChangesUntil(e);let s;for(;void 0!==(s=i.pop());){const e=this.schemas.get(s.model);t.push(this.buildRollbackSqlAndParameters(e,s.primaryKey,s))}return t}static fieldValuesFromChanges(e,t=!1){return t?s.makeJsonObject(e.propertyChanges,e=>e.name,e=>e.original):s.makeJsonObject(e.propertyChanges,e=>e.name,e=>e.current)}buildSqlAndParameters(e,t,i){const s=n.fieldValuesFromChanges(i);switch(s[r.ENTITY_VERSION_PROPERTY]=i.dbVersion,i.type){case r.EntityChangeType.New:return this.sqlBuilder.buildInsert(e,s);case r.EntityChangeType.Modify:return this.sqlBuilder.buildUpdate(e,t,s,i.dbVersion-1);case r.EntityChangeType.Delete:return this.sqlBuilder.buildDelete(e,t);default:throw new Error(`Invalid EntityChangeType '${i.type}'`)}}buildRollbackSqlAndParameters(e,t,i){const s=n.fieldValuesFromChanges(i,!0);switch(i.type){case r.EntityChangeType.New:return this.sqlBuilder.buildDelete(e,t);case r.EntityChangeType.Modify:return s[r.ENTITY_VERSION_PROPERTY]=i.dbVersion-1,this.sqlBuilder.buildUpdate(e,t,s,i.dbVersion);case r.EntityChangeType.Delete:return this.sqlBuilder.buildInsert(e,s);default:throw new Error(`Invalid EntityChangeType '${i.type}'`)}}}t.BasicTrackerSqlBuilder=n},function(e,t){e.exports=require("json-sql")},function(e,t){e.exports=require("lodash")},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(1),r=i(0);class n{constructor(e,t){this.name=e,this.indexFields=t,this.indexMap=new Map}get indexName(){return this.name}get fields(){return this.indexFields}getIndexKey(e){return JSON.stringify(e)}exists(e){return this.indexMap.has(this.getIndexKey(e))}get(e){return this.indexMap.get(this.getIndexKey(e))}add(e,t){const i=this.getIndexKey(e);if(this.indexMap.has(i))throw new Error(`Unique named '${this.name}' key = '${i}' exists already`);this.indexMap.set(i,t)}delete(e){this.indexMap.delete(this.getIndexKey(e))}}t.DefaultEntityUniqueIndex=n;class a{constructor(e,t){this.cache=e,this.cache.onEvit=this.afterEvit.bind(this),this.indexes=new Map,t.forEach(e=>this.indexes.set(e.name,this.createUniqueIndex(e)))}createUniqueIndex(e){return new n(e.name,e.properties)}afterEvit(e,t){this.indexes.forEach(e=>{let i=s.partialCopy(t,e.fields);e.delete(i)})}has(e){return this.cache.has(e)}set(e,t){this.cache.has(e)&&this.evit(e),this.cache.set(e,t),this.indexes.forEach(i=>{if(i.fields.some(e=>!t[e]))return;let r=s.partialCopy(t,i.fields);i.add(r,String(e))})}get(e){return this.cache.get(e)}forEach(e){this.cache.forEach(e)}evit(e){let t=this.cache.get(e);void 0!==t&&(this.cache.evit(e),this.afterEvit(e,t))}getUnique(e,t){let i=this.indexes.get(e).get(t);return void 0===i?void 0:this.cache.get(i)}clear(){this.forEach((e,t)=>this.evit(t))}}t.UniquedCache=a;t.UniquedEntityCache=class{constructor(e,t){this.log=e,this.modelSchemas=t,this.modelCaches=new Map}createCache(e){throw new s.NotImplementError}registerModel(e,t){const i=e.modelName;if(this.modelCaches.has(i))throw new Error(`model '${i}' exists already`);let s=this.createCache(e);this.modelCaches.set(i,new a(s,t))}unRegisterModel(e){this.modelCaches.delete(e)}getModelCache(e){const t=this.modelSchemas.get(e);if(void 0===t)throw new Error(`Model schema ( name = '${e}' )  does not exists`);return this.modelCaches.has(e)||this.registerModel(t,t.uniqueIndexes),this.modelCaches.get(e)}getCacheKey(e){return s.isPrimitiveKey(e)?String(e):JSON.stringify(e)}clear(e){if(r.isString(e))return this.getModelCache(e).clear(),void this.modelCaches.delete(e);for(let e of this.modelCaches.values())e.clear();this.modelCaches.clear()}get models(){return new Array(...this.modelSchemas.values())}get(e,t){let i=this.getModelCache(e),s=this.getCacheKey(t);return this.modelCaches.has(e)&&i.has(s)?i.get(s):void 0}getUnique(e,t,i){return this.getModelCache(e).getUnique(t,i)}existsUnique(e,t,i){return void 0!==this.getUnique(e,t,i)}refreshCached(e,t,i){const s=this.get(e,t);if(void 0===s)return!1;const r=i.map(e=>e.name);return this.modelSchemas.get(e).hasUniqueProperty(...r)?(this.log.traceEnabled&&this.log.trace(`refresh cached with uniqued index, key = ${JSON.stringify(t)} modifier = ${JSON.stringify(i)}`),this.evit(e,t),i.forEach(e=>s[e.name]=e.value),this.put(e,t,s),!0):(this.log.traceEnabled&&this.log.trace(`refresh cached entity, key = ${JSON.stringify(t)} modifier = ${JSON.stringify(i)}`),i.forEach(e=>s[e.name]=e.value),!1)}getAll(e,t){let i=new Array,s=this.getModelCache(e);if(void 0!==s)return s.forEach(e=>{(!t||t&&t(e))&&i.push(e)}),i}put(e,t,i){this.log.traceEnabled&&this.log.trace(`put cache, model = ${e}, key = ${JSON.stringify(t)}, entity = ${JSON.stringify(i)}`),this.getModelCache(e).set(this.getCacheKey(t),i)}evit(e,t){let i=this.getCacheKey(t);this.log.traceEnabled&&this.log.trace(`evit cache, model = ${e}, key = ${i}`);const s=this.getModelCache(e);s&&s.evit(i)}exists(e,t){return void 0!==this.get(e,this.getCacheKey(t))}existsModel(e){return this.modelCaches.has(e)}dumpCache(){let e="--------------  DUMP CACHE  ----------------\n\n";return this.modelCaches.forEach((t,i)=>{e+=`--------------Model ${i}----------------\n`,t.forEach((t,i)=>{e+=`key = ${this.getCacheKey(i)}, entity = {${JSON.stringify(t)}} \n`}),e+="\n"}),e+="--------------   END   DUMP  ----------------\n"}}},function(e,t){e.exports=require("lru-cache")},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(19),r=i(18),n=i(2);class a{constructor(e,t){this.modelSchema=e,this.lruCache=new s({max:t,dispose:this.doEvit.bind(this)})}doEvit(e,t){this.postEvit&&this.postEvit(e,t)}get onEvit(){return this.postEvit}set onEvit(e){this.postEvit=e}get model(){return this.modelSchema}clear(){this.lruCache.reset()}has(e){return this.lruCache.has(e)}get(e){return this.lruCache.get(e)}forEach(e){this.lruCache.forEach(e)}set(e,t){this.lruCache.set(e,t)}evit(e){this.lruCache.del(e)}exists(e){return this.lruCache.has(e)}}class o extends r.UniquedEntityCache{constructor(e){super(n.LogManager.getLogger("LRUEntityCache"),e)}getMaxCachedCount(e){const t=e.maxCached||o.DEFULT_MAX_CACHED_COUNT;return Math.max(o.MIN_CACHED_COUNT,t)}createCache(e){return new a(e,this.getMaxCachedCount(e))}}o.MIN_CACHED_COUNT=100,o.DEFULT_MAX_CACHED_COUNT=5e4,t.LRUEntityCache=o},function(e,t){e.exports=require("level-secondary")},function(e,t){e.exports=require("level")},function(e,t){e.exports=require("level-sublevel")},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(0),r=i(23),n=i(22),a=i(21);function o(e){let t=null;return e||(t=(e=function(){let e,t=new Promise((t,i)=>{e=((e,s)=>e?i(e):t(s))});return e.promise=t,e}()).promise),{callback:e,promise:t}}t.SubLevelMeta=class{constructor(e,t,i=new Array){this.subName=e,this.keyField=t,this.indexFields=(new Array).concat(i)}findIndexOfFieldName(e){return this.indexFields.findIndex(t=>e===t.fieldName)}existsIndex(e){return this.findIndexOfFieldName(e)>-1}addIndex(e,t){if(this.existsIndex(e))throw new Error(`Index of field '${e}' already exists`);return this.indexFields.push({fieldName:e,calcIndex:t}),this}removeIndex(e){const t=this.findIndexOfFieldName(e);return t>-1&&this.indexFields.slice(t,1),this}};class l{constructor(e,t,i={}){this.dbDir=e,this.subMetas=(new Array).concat(t),this.subLevels=new Map,this.leveldb=null}async init(){this.leveldb=n(this.dbDir,{valueEncoding:"json"}),this.subLeveldb=r(this.leveldb),this.subMetas.forEach(e=>this.registerSubLevel(e))}registerSubLevel(e){const t=this.subLeveldb.sublevel(e.subName),i=new c(t,e.subName,e.keyField,...e.indexFields);this.subLevels.set(e.subName,i)}static isKeyNotFoundError(e){return e&&"NotFoundError"===e.name}get level(){return this.leveldb}getSubLevel(e){const t=this.subLevels.get(e);if(!t)throw new Error(`No such subLevel name = '${e}'`);return t}open(e){let t=this,{callback:i,promise:s}=o(e);return this.isOpen?(process.nextTick(i,null,t),s):((async()=>{try{await this.init(),process.nextTick(i,null,t)}catch(e){process.nextTick(i,e,t)}})(),s)}close(e){let t=this,{callback:i,promise:s}=o(e);return this.isClosed?(process.nextTick(i,null,t),s):((async()=>{try{await this.leveldb.close(),this.leveldb=null,process.nextTick(i,null,t)}catch(e){process.nextTick(i,e)}})(),s)}get isOpen(){return this.leveldb&&this.leveldb.isOpen()}get isClosed(){return!this.leveldb||this.leveldb.isClosed()}dump(){return new Promise((e,t)=>{let i=new Array;this.leveldb.createReadStream().on("data",e=>i.push(`key= ${e.key}, value= ${e.value}`)).on("error",e=>t(e)).on("end",()=>e(i.join("\r\n")))})}}t.LevelDB=l;class c{get name(){return this.subName}get indexes(){return this.indexArray}constructor(e,t,i,...s){this.subLevelDb=e,this.subName=t,this.keyField=i,this.indexArray=(new Array).concat(...s),this.indexedSubLevels=new Map,this.indexArray.forEach(t=>{let i=a(e,t.fieldName,t.calcIndex);this.indexedSubLevels.set(t.fieldName,i)})}get key(){return this.keyField}keyNotFoundThenUndefined(e){return e?(t,i)=>{e(l.isKeyNotFoundError(t)?null:t,i)}:void 0}async get(e,t,i){const s=this.subLevelDb;let{callback:r,promise:n}=o(i);try{s.get(e,t,this.keyNotFoundThenUndefined(r))}catch(e){r(l.isKeyNotFoundError(e)?void 0:e,void 0)}return n}byIndex(e){const t=this.indexedSubLevels.get(e);if(!t)throw new Error(`No such index field = '${e}'`);return t}async getBy(e,t,i){const s=this.byIndex(e);let{callback:r,promise:n}=o(i);try{s.get(t,this.keyNotFoundThenUndefined(r))}catch(e){r(l.isKeyNotFoundError(e)?void 0:e,void 0)}return n}async put(e,t,i){let{callback:s,promise:r}=o(i);try{this.subLevelDb.put(e,t,s)}catch(e){s(e,void 0)}return r}async del(e,t){let{callback:i,promise:s}=o(t);try{this.subLevelDb.del(e,i)}catch(e){i(e,void 0)}return s}async batch(e,t,i){if(0===arguments.length)return this.subLevelDb.batch();let r=t&&!s.isFunction(t),n=r?i:t,{callback:a,promise:l}=o(n);try{r?this.subLevelDb.batch(e,t,a):this.subLevelDb.batch(e,a)}catch(e){a(e,void 0)}return l}createReadStream(e){return this.subLevelDb.createReadStream(e)}createKeyStream(e){return this.subLevelDb.createKeyStream(e)}createValueStream(e){return this.subLevelDb.createValueStream(e)}}},function(e,t){e.exports=require("events")},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(25),r=i(0),n=i(1),a=i(9),o=i(8),l=i(6),c=i(2),h=i(10),u=i(3);class d extends s.EventEmitter{constructor(e,t,i){n.CodeContract.argument("dbPath",()=>n.CodeContract.notNullOrWhitespace(e)),n.CodeContract.argument("levelBlockDir",()=>n.CodeContract.notNullOrWhitespace(t)),super(),this.options=i||{cachedBlockCount:10,maxBlockHistoryHold:10},this.commitBlockHooks=new Array,this.rollbackBlockHooks=new Array,this.schemas=new Map,this.log=c.LogManager.getLogger("SmartDB"),this.blockDB=new a.LevelBlock(t),this.cachedBlocks=new h.BlockCache(this.options.cachedBlockCount),this.connection=new l.SqliteConnection({storage:e}),this.blockSession=new o.DbSession(this.connection,this.loadHistroyFromLevelDB.bind(this),{name:"Block"}),this.localSession=new o.DbSession(this.connection,null,{name:"Local"})}getSchema(e,t=!1,i=!1){const s=r.isString(e)?String(e):e.name,a=this.schemas.get(s);return t&&n.CodeContract.verify(void 0!==a,`unregistered model '${s}'`),i&&n.CodeContract.verify(!a.isReadonly,`model '${s}' is readonly`),a}async loadHistroyFromLevelDB(e,t){return await this.blockDB.getHistoryChanges(e,t)}getSession(e){return e.isLocal?this.localSession:this.blockSession}preCommitBlock(e){this.commitBlockHooks.forEach(t=>t.hook(e))}postCommitBlock(e){this.emit("newBlock",e)}preRollbackBlock(e,t){this.rollbackBlockHooks.forEach(i=>i.hook(e,t))}postRollbackBlock(e,t){this.emit("rollbackBlock",{from:e,to:t})}get transactionSchema(){return this.getSchema(d.TRANSACTION_MODEL_NAME,!0,!0)}registerCommitBlockHook(e,t){n.CodeContract.argument("hookFunc",()=>n.CodeContract.notNull(t)),n.CodeContract.argument("name",()=>n.CodeContract.notNullOrWhitespace(e)),n.CodeContract.argument("name",this.commitBlockHooks.every(t=>t.name!==e.trim()),`hook named '${e}' exist already`),this.commitBlockHooks.push({name:e,hook:t})}unregisterCommitBlockHook(e){n.CodeContract.argument("name",()=>n.CodeContract.notNullOrWhitespace(e));let t=this.commitBlockHooks.findIndex(t=>t.name===e.trim());t>=0&&this.commitBlockHooks.slice(t)}registerRollbackBlockHook(e,t){n.CodeContract.argument("hookFunc",()=>n.CodeContract.notNull(t)),n.CodeContract.argument("name",()=>n.CodeContract.notNullOrWhitespace(e)),n.CodeContract.argument("name",this.rollbackBlockHooks.some(t=>t.name===e.trim()),`hook named '${e}' exist already`),this.rollbackBlockHooks.push({name:e,hook:t})}unregisterRollbackBlockHook(e){n.CodeContract.argument("name",()=>n.CodeContract.notNullOrWhitespace(e));let t=this.rollbackBlockHooks.findIndex(t=>t.name===e.trim());t>=0&&this.rollbackBlockHooks.slice(t)}async init(e){n.CodeContract.argument("schemas",()=>n.CodeContract.notNull(e)),await this.connection.connect(),await this.blockDB.open(),await this.syncSchemas(e),await this.ensureLastBlockLoaded(),await this.blockSession.initSerial(this.blockDB.lastBlockHeight),await this.localSession.initSerial(-1),this.emit("ready",this)}async syncSchemas(e){for(const t of e){this.schemas.set(t.modelName,t);let e=this.getSession(t);if(e.registerSchema(t),e.syncSchema(t),this.log.infoEnabled&&this.log.info(`sync schema model = ${t.modelName} `),t.memCached){let i=await e.getMany(t,{},!0);this.log.infoEnabled&&this.log.info(`model ${t.modelName} cached ${i.length} entities `)}}if(void 0===this.transactionSchema)throw new Error("Transaction model is not found")}async updateSchema(e){n.CodeContract.argument("schema",()=>n.CodeContract.notNull(e));const t=this.getSchema(e.modelName),i=this.getSession(t);await i.updateSchema(e),this.log.infoEnabled&&this.log.info(`model ${e.modelName} schema updated `)}async close(){await this.blockSession.close(),await this.localSession.close(),await this.blockDB.close(),this.emit("closed",this)}get lastBlockHeight(){return this.blockDB.lastBlockHeight}get blocksCount(){return this.lastBlockHeight+1}get lastBlock(){return this.cachedBlocks.get(this.lastBlockHeight)}lockInCurrentBlock(e,t=!1){return this.blockSession.lockInThisSession(e,t)}lock(e){this.lockInCurrentBlock(e,!1)}tryLock(e){return this.lockInCurrentBlock(e,!0)}beginContract(){this.blockSession.beginEntityTransaction()}commitContract(){this.blockSession.commitEntityTransaction()}rollbackContract(){this.blockSession.rollbackEntityTransaction()}beginBlock(e){n.CodeContract.argument("block",()=>n.CodeContract.notNull(e)),n.CodeContract.argument("block",e.height===this.lastBlockHeight+1,`invalid block height ${e.height}, last = ${this.lastBlockHeight}`),this.log.infoEnabled&&this.log.info(`BEGIN block height = ${e.height}`),this.currentBlock=e}async commitBlock(){if(!this.currentBlock)throw new Error("Current block is null");this.log.traceEnabled&&this.log.trace(`BEGIN commitBlock height = ${this.currentBlock.height}`),this.preCommitBlock(this.currentBlock);let e=Object.assign({},this.currentBlock);Reflect.deleteProperty(e,"transactions"),u.Utils.Performace.time("Append block"),await this.blockDB.appendBlock(e,this.blockSession.getChanges()),u.Utils.Performace.endTime();try{return await this.blockSession.saveChanges(this.currentBlock.height),this.cachedBlocks.push(this.currentBlock),this.currentBlock=null,this.postCommitBlock(this.lastBlock),this.log.infoEnabled&&this.log.info(`SUCCESS commitBlock height = ${this.lastBlockHeight}`),this.lastBlockHeight}catch(e){throw this.log.errorEnaled&&this.log.error(`FAILD commitBlock ( height = ${this.currentBlock.height} )`,e),await this.blockDB.deleteLastBlock(this.currentBlock.height),e}}async rollbackBlock(e){n.CodeContract.argument("height",!e||e<=this.lastBlockHeight,`height must less or equal lastBlockHeight ${this.lastBlockHeight}`);const t=this.currentBlock?this.currentBlock.height:this.lastBlockHeight,i=void 0===e?this.lastBlockHeight:e;this.log.traceEnabled&&this.log.trace(`BEGIN rollbackBlock ( height : ${t} -> ${i} )`),this.preRollbackBlock(t,i);try{for(await this.blockSession.rollbackChanges(i);this.lastBlockHeight>i;)await this.blockDB.deleteLastBlock(this.lastBlockHeight),this.cachedBlocks.evitUntil(this.lastBlockHeight);await this.ensureLastBlockLoaded(),this.currentBlock=null,this.postRollbackBlock(t,i),this.log.infoEnabled&&this.log.info(`SUCCESS rollbackBlock ( height : ${t} -> ${i} )`)}catch(e){throw this.log.errorEnaled&&this.log.error(`FAILD rollbackBlock ( height : ${t} -> ${i} )`,e),e}}async saveLocalChanges(){return await this.localSession.saveChanges()}async rollbackLocalChanges(e){n.CodeContract.argument("serial",e>=0,"serial must great or equal zero"),await this.localSession.rollbackChanges(e)}create(e,t){n.CodeContract.argument("model",()=>n.CodeContract.notNull(e)),n.CodeContract.argument("entity",()=>n.CodeContract.notNull(t));const i=this.getSchema(e,!0,!0);return this.getSession(i).create(i,t)}createOrLoad(e,t){n.CodeContract.argument("model",()=>n.CodeContract.notNull(e)),n.CodeContract.argument("entity",()=>n.CodeContract.notNull(t));const i=this.getSchema(e,!0,!0),s=this.loadSync(e,i.getNormalizedPrimaryKey(t));return{create:void 0===s,entity:s||this.create(e,t)}}increase(e,t,i){n.CodeContract.argument("model",()=>n.CodeContract.notNull(e)),n.CodeContract.argument("increasements",()=>n.CodeContract.notNull(t)),n.CodeContract.argument("key",()=>n.CodeContract.notNull(i));const s=this.getSchema(e,!0,!0);return this.getSession(s).increase(s,i,t)}update(e,t,i){n.CodeContract.argument("model",()=>n.CodeContract.notNull(e)),n.CodeContract.argument("modifier",()=>n.CodeContract.notNull(t)),n.CodeContract.argument("key",()=>n.CodeContract.notNull(i));const s=this.getSchema(e,!0,!0);if(!0===this.options.checkModifier){const e=Object.keys(t),i=u.Utils.Array.without(s.properties,...e);if(i.length>0)throw new Error(`modifier or entity contains property which is not defined in model (${JSON.stringify(i)})`)}this.getSession(s).update(s,i,t)}del(e,t){n.CodeContract.argument("model",()=>n.CodeContract.notNull(e)),n.CodeContract.argument("key",()=>n.CodeContract.notNull(t));const i=this.getSchema(e,!0,!0);this.getSession(i).delete(i,t)}async load(e,t){n.CodeContract.argument("model",()=>n.CodeContract.notNull(e)),n.CodeContract.argument("key",()=>n.CodeContract.notNull(t));const i=this.getSchema(e,!0);return await this.getSession(i).load(i,t)}loadSync(e,t){n.CodeContract.argument("model",()=>n.CodeContract.notNull(e)),n.CodeContract.argument("key",()=>n.CodeContract.notNull(t));const i=this.getSchema(e,!0);return this.getSession(i).loadSync(i,t)}async loadMany(e,t,i=!0){n.CodeContract.argument("model",()=>n.CodeContract.notNull(e));const s=this.getSchema(e,!0);return await this.getSession(s).getMany(s,t,i)}get(e,t){n.CodeContract.argument("model",()=>n.CodeContract.notNull(e)),n.CodeContract.argument("key",()=>n.CodeContract.notNull(t));const i=this.getSchema(e,!0);return this.getSession(i).getCachedEntity(i,t)}getAll(e,t){n.CodeContract.argument("model",()=>n.CodeContract.notNull(e));const i=this.getSchema(e,!0);return n.CodeContract.argument("model",i.memCached,"getAll only support for memory model"),this.getSession(i).getAll(i,t)}async find(e,t,i,s,r,a){n.CodeContract.argument("model",()=>n.CodeContract.notNull(e));const o=this.getSchema(e,!0);return await this.getSession(o).query(o,t,i,s,r,a)}async findOne(e,t){let i=await this.findAll(e,t);const s=this.getSchema(e,!0);if(i.length>1)throw new Error(`many entities found ( model = '${s.modelName}' , params = '${JSON.stringify(t)}' )`);return 0===i.length?void 0:i[0]}async findAll(e,t){n.CodeContract.argument("model",()=>n.CodeContract.notNull(e));const i=this.getSchema(e,!0);return await this.getSession(i).queryByJson(i,t)}async exists(e,t){n.CodeContract.argument("model",()=>n.CodeContract.notNull(e));const i=this.getSchema(e,!0);return await this.getSession(i).exists(i,t)}async count(e,t){n.CodeContract.argument("model",()=>n.CodeContract.notNull(e));const i=this.getSchema(e,!0);return await this.getSession(i).count(i,t)}async ensureLastBlockLoaded(){if(void 0===this.lastBlock&&this.lastBlockHeight>=0){let e=await this.getBlockByHeight(this.lastBlockHeight,!0);this.log.infoEnabled&&this.log.info(`SUCCESS load last block (height = ${e.height}, id = '${e.id}')`),this.cachedBlocks.push(e)}}async getBlockByHeight(e,t=!1){n.CodeContract.argument("height",e>=0,"height must great or equal zero");let i=this.copyCachedBlock(()=>this.cachedBlocks.get(e),t);if(i)return i;let s=await this.blockDB.getBlock(e);if(!t||void 0===s)return s;return(await this.attachTransactions([s],async()=>await this.blockSession.query(this.transactionSchema,{height:s.height})))[0]}async getBlockById(e,t=!1){n.CodeContract.argument("blockId",()=>n.CodeContract.notNullOrWhitespace(e));let i=this.copyCachedBlock(()=>this.cachedBlocks.getById(e),t);if(i)return i;let s=await this.blockDB.getBlockById(e);if(!t||void 0===s)return s;return(await this.attachTransactions([s],async()=>await this.blockSession.query(this.transactionSchema,{height:s.height})))[0]}async getBlocksByHeightRange(e,t,i=!1){n.CodeContract.argument("minHeight, maxHeight",e>=0&&t>=e,"minHeight or maxHeight is invalid");let s=await this.blockDB.getBlocksByHeightRange(e,t);return i?await this.attachTransactions(s,async()=>await this.blockSession.query(this.transactionSchema,{height:{$in:s.map(e=>e.height)}})):s}async getBlocksByIds(e,t=!1){n.CodeContract.argument("blockIds",()=>n.CodeContract.notNull(e));let i=await this.blockDB.getBlocksByIds(e);return t?await this.attachTransactions(i,async()=>await this.blockSession.query(this.transactionSchema,{height:{$in:i.map(e=>e.height)}})):i}async attachTransactions(e,t){let i=new Map;return(await t()).forEach(e=>{i.has(e.blockId)||i.set(e.blockId,new Array),i.get(e.blockId).push(e)}),e.forEach(e=>e.transactions=i.get(e.id)),e}copyCachedBlock(e,t){let i=e();if(void 0===i)return;let s=Object.assign({},i);return t||Reflect.deleteProperty(s,"transactions"),s}}d.TRANSACTION_MODEL_NAME="Transaction",t.SmartDB=d},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=i(26),r=i(5),n=i(8),a=i(6),o=i(2),l=i(9);!function(e){e.SmartDB=s.SmartDB,e.ModelSchema=r.ModelSchema,e.LogManager=o.LogManager,e.LogLevel=o.LogLevel,e.DbSession=n.DbSession,e.LevelBlock=l.LevelBlock,e.SqliteConnection=a.SqliteConnection}(t.AschCore||(t.AschCore={}))}]);